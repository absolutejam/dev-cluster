// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema DestinationRule
 */
export class DestinationRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DestinationRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'DestinationRule',
  }

  /**
   * Renders a Kubernetes manifest for "DestinationRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DestinationRuleProps = {}): any {
    return {
      ...DestinationRule.GVK,
      ...toJson_DestinationRuleProps(props),
    };
  }

  /**
   * Defines a "DestinationRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DestinationRuleProps = {}) {
    super(scope, id, {
      ...DestinationRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DestinationRule.GVK,
      ...toJson_DestinationRuleProps(resolved),
    };
  }
}

/**
 * @schema DestinationRule
 */
export interface DestinationRuleProps {
  /**
   * @schema DestinationRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
   *
   * @schema DestinationRule#spec
   */
  readonly spec?: DestinationRuleSpec;

}

/**
 * Converts an object of type 'DestinationRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleProps(obj: DestinationRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DestinationRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
 *
 * @schema DestinationRuleSpec
 */
export interface DestinationRuleSpec {
  /**
   * A list of namespaces to which this destination rule is exported.
   *
   * @schema DestinationRuleSpec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The name of a service from the service registry.
   *
   * @schema DestinationRuleSpec#host
   */
  readonly host: string;

  /**
   * One or more named sets that represent individual versions of a service.
   *
   * @schema DestinationRuleSpec#subsets
   */
  readonly subsets?: DestinationRuleSpecSubsets[];

  /**
   * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
   *
   * @schema DestinationRuleSpec#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleSpecTrafficPolicy;

  /**
   * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
   *
   * @schema DestinationRuleSpec#workloadSelector
   */
  readonly workloadSelector?: DestinationRuleSpecWorkloadSelector;

}

/**
 * Converts an object of type 'DestinationRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpec(obj: DestinationRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportTo': obj.exportTo?.map(y => y),
    'host': obj.host,
    'subsets': obj.subsets?.map(y => toJson_DestinationRuleSpecSubsets(y)),
    'trafficPolicy': toJson_DestinationRuleSpecTrafficPolicy(obj.trafficPolicy),
    'workloadSelector': toJson_DestinationRuleSpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsets
 */
export interface DestinationRuleSpecSubsets {
  /**
   * Labels apply a filter over the endpoints of a service in the service registry.
   *
   * @schema DestinationRuleSpecSubsets#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the subset.
   *
   * @schema DestinationRuleSpecSubsets#name
   */
  readonly name: string;

  /**
   * Traffic policies that apply to this subset.
   *
   * @schema DestinationRuleSpecSubsets#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleSpecSubsetsTrafficPolicy;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsets(obj: DestinationRuleSpecSubsets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'trafficPolicy': toJson_DestinationRuleSpecSubsetsTrafficPolicy(obj.trafficPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
 *
 * @schema DestinationRuleSpecTrafficPolicy
 */
export interface DestinationRuleSpecTrafficPolicy {
  /**
   * @schema DestinationRuleSpecTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleSpecTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleSpecTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleSpecTrafficPolicyPortLevelSettings[];

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleSpecTrafficPolicyTls;

  /**
   * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
   *
   * @schema DestinationRuleSpecTrafficPolicy#tunnel
   */
  readonly tunnel?: DestinationRuleSpecTrafficPolicyTunnel;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicy(obj: DestinationRuleSpecTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleSpecTrafficPolicyConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleSpecTrafficPolicyLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleSpecTrafficPolicyOutlierDetection(obj.outlierDetection),
    'portLevelSettings': obj.portLevelSettings?.map(y => toJson_DestinationRuleSpecTrafficPolicyPortLevelSettings(y)),
    'tls': toJson_DestinationRuleSpecTrafficPolicyTls(obj.tls),
    'tunnel': toJson_DestinationRuleSpecTrafficPolicyTunnel(obj.tunnel),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
 *
 * @schema DestinationRuleSpecWorkloadSelector
 */
export interface DestinationRuleSpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
   *
   * @schema DestinationRuleSpecWorkloadSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DestinationRuleSpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecWorkloadSelector(obj: DestinationRuleSpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Traffic policies that apply to this subset.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicy
 */
export interface DestinationRuleSpecSubsetsTrafficPolicy {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings[];

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleSpecSubsetsTrafficPolicyTls;

  /**
   * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#tunnel
   */
  readonly tunnel?: DestinationRuleSpecSubsetsTrafficPolicyTunnel;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicy(obj: DestinationRuleSpecSubsetsTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection(obj.outlierDetection),
    'portLevelSettings': obj.portLevelSettings?.map(y => toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings(y)),
    'tls': toJson_DestinationRuleSpecSubsetsTrafficPolicyTls(obj.tls),
    'tunnel': toJson_DestinationRuleSpecSubsetsTrafficPolicyTunnel(obj.tunnel),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyConnectionPool
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleSpecTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecTrafficPolicyConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPool(obj: DestinationRuleSpecTrafficPolicyConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleSpecTrafficPolicyConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancer
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecTrafficPolicyLoadBalancerSimple;

  /**
   * Represents the warmup duration of Service.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancer(obj: DestinationRuleSpecTrafficPolicyLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyOutlierDetection
 */
export interface DestinationRuleSpecTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyOutlierDetection(obj: DestinationRuleSpecTrafficPolicyOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * Specifies the number of a port on the destination service on which this policy is being applied.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleSpecTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleSpecTrafficPolicyPortLevelSettingsTls;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettings(obj: DestinationRuleSpecTrafficPolicyPortLevelSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection(obj.outlierDetection),
    'port': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsPort(obj.port),
    'tls': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecTrafficPolicyTls
 */
export interface DestinationRuleSpecTrafficPolicyTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleSpecTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyTls(obj: DestinationRuleSpecTrafficPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
 *
 * @schema DestinationRuleSpecTrafficPolicyTunnel
 */
export interface DestinationRuleSpecTrafficPolicyTunnel {
  /**
   * Specifies which protocol to use for tunneling the downstream connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyTunnel#protocol
   */
  readonly protocol?: string;

  /**
   * Specifies a host to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleSpecTrafficPolicyTunnel#targetHost
   */
  readonly targetHost: string;

  /**
   * Specifies a port to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleSpecTrafficPolicyTunnel#targetPort
   */
  readonly targetPort: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyTunnel(obj: DestinationRuleSpecTrafficPolicyTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
    'targetHost': obj.targetHost,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPool(obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple;

  /**
   * Represents the warmup duration of Service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection(obj: DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * Specifies the number of a port on the destination service on which this policy is being applied.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(obj.outlierDetection),
    'port': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort(obj.port),
    'tls': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyTls
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleSpecSubsetsTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyTls(obj: DestinationRuleSpecSubsetsTrafficPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyTunnel
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyTunnel {
  /**
   * Specifies which protocol to use for tunneling the downstream connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTunnel#protocol
   */
  readonly protocol?: string;

  /**
   * Specifies a host to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTunnel#targetHost
   */
  readonly targetHost: string;

  /**
   * Specifies a port to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTunnel#targetPort
   */
  readonly targetPort: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyTunnel(obj: DestinationRuleSpecSubsetsTrafficPolicyTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
    'targetHost': obj.targetHost,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPoolHttp(obj: DestinationRuleSpecTrafficPolicyConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcp(obj: DestinationRuleSpecTrafficPolicyConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash(obj: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting(obj: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleSpecTrafficPolicyLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple;

  /**
   * Represents the warmup duration of Service.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the number of a port on the destination service on which this policy is being applied.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsPort(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsTls(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * @schema DestinationRuleSpecTrafficPolicyTlsMode
 */
export enum DestinationRuleSpecTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp(obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp(obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple;

  /**
   * Represents the warmup duration of Service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the number of a port on the destination service on which this policy is being applied.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyTlsMode
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive(obj: DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev(obj: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash(obj: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema DestinationRuleV1Beta1
 */
export class DestinationRuleV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DestinationRuleV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'DestinationRule',
  }

  /**
   * Renders a Kubernetes manifest for "DestinationRuleV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DestinationRuleV1Beta1Props = {}): any {
    return {
      ...DestinationRuleV1Beta1.GVK,
      ...toJson_DestinationRuleV1Beta1Props(props),
    };
  }

  /**
   * Defines a "DestinationRuleV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DestinationRuleV1Beta1Props = {}) {
    super(scope, id, {
      ...DestinationRuleV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DestinationRuleV1Beta1.GVK,
      ...toJson_DestinationRuleV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema DestinationRuleV1Beta1
 */
export interface DestinationRuleV1Beta1Props {
  /**
   * @schema DestinationRuleV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
   *
   * @schema DestinationRuleV1Beta1#spec
   */
  readonly spec?: DestinationRuleV1Beta1Spec;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1Props(obj: DestinationRuleV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DestinationRuleV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
 *
 * @schema DestinationRuleV1Beta1Spec
 */
export interface DestinationRuleV1Beta1Spec {
  /**
   * A list of namespaces to which this destination rule is exported.
   *
   * @schema DestinationRuleV1Beta1Spec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The name of a service from the service registry.
   *
   * @schema DestinationRuleV1Beta1Spec#host
   */
  readonly host: string;

  /**
   * One or more named sets that represent individual versions of a service.
   *
   * @schema DestinationRuleV1Beta1Spec#subsets
   */
  readonly subsets?: DestinationRuleV1Beta1SpecSubsets[];

  /**
   * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
   *
   * @schema DestinationRuleV1Beta1Spec#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleV1Beta1SpecTrafficPolicy;

  /**
   * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
   *
   * @schema DestinationRuleV1Beta1Spec#workloadSelector
   */
  readonly workloadSelector?: DestinationRuleV1Beta1SpecWorkloadSelector;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1Spec(obj: DestinationRuleV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportTo': obj.exportTo?.map(y => y),
    'host': obj.host,
    'subsets': obj.subsets?.map(y => toJson_DestinationRuleV1Beta1SpecSubsets(y)),
    'trafficPolicy': toJson_DestinationRuleV1Beta1SpecTrafficPolicy(obj.trafficPolicy),
    'workloadSelector': toJson_DestinationRuleV1Beta1SpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsets
 */
export interface DestinationRuleV1Beta1SpecSubsets {
  /**
   * Labels apply a filter over the endpoints of a service in the service registry.
   *
   * @schema DestinationRuleV1Beta1SpecSubsets#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the subset.
   *
   * @schema DestinationRuleV1Beta1SpecSubsets#name
   */
  readonly name: string;

  /**
   * Traffic policies that apply to this subset.
   *
   * @schema DestinationRuleV1Beta1SpecSubsets#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicy;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsets(obj: DestinationRuleV1Beta1SpecSubsets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'trafficPolicy': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicy(obj.trafficPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicy
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicy {
  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings[];

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleV1Beta1SpecTrafficPolicyTls;

  /**
   * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#tunnel
   */
  readonly tunnel?: DestinationRuleV1Beta1SpecTrafficPolicyTunnel;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicy(obj: DestinationRuleV1Beta1SpecTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection(obj.outlierDetection),
    'portLevelSettings': obj.portLevelSettings?.map(y => toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings(y)),
    'tls': toJson_DestinationRuleV1Beta1SpecTrafficPolicyTls(obj.tls),
    'tunnel': toJson_DestinationRuleV1Beta1SpecTrafficPolicyTunnel(obj.tunnel),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
 *
 * @schema DestinationRuleV1Beta1SpecWorkloadSelector
 */
export interface DestinationRuleV1Beta1SpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
   *
   * @schema DestinationRuleV1Beta1SpecWorkloadSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecWorkloadSelector(obj: DestinationRuleV1Beta1SpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Traffic policies that apply to this subset.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicy {
  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings[];

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls;

  /**
   * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#tunnel
   */
  readonly tunnel?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicy(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection(obj.outlierDetection),
    'portLevelSettings': obj.portLevelSettings?.map(y => toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings(y)),
    'tls': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls(obj.tls),
    'tunnel': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel(obj.tunnel),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool(obj: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple;

  /**
   * Represents the warmup duration of Service.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection(obj: DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * Specifies the number of a port on the destination service on which this policy is being applied.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection(obj.outlierDetection),
    'port': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort(obj.port),
    'tls': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleV1Beta1SpecTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyTls(obj: DestinationRuleV1Beta1SpecTrafficPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyTunnel
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyTunnel {
  /**
   * Specifies which protocol to use for tunneling the downstream connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTunnel#protocol
   */
  readonly protocol?: string;

  /**
   * Specifies a host to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTunnel#targetHost
   */
  readonly targetHost: string;

  /**
   * Specifies a port to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTunnel#targetPort
   */
  readonly targetPort: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyTunnel(obj: DestinationRuleV1Beta1SpecTrafficPolicyTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
    'targetHost': obj.targetHost,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple;

  /**
   * Represents the warmup duration of Service.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * Specifies the number of a port on the destination service on which this policy is being applied.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(obj.outlierDetection),
    'port': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort(obj.port),
    'tls': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel {
  /**
   * Specifies which protocol to use for tunneling the downstream connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel#protocol
   */
  readonly protocol?: string;

  /**
   * Specifies a host to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel#targetHost
   */
  readonly targetHost: string;

  /**
   * Specifies a port to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel#targetPort
   */
  readonly targetPort: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
    'targetHost': obj.targetHost,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp(obj: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp(obj: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple;

  /**
   * Represents the warmup duration of Service.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the number of a port on the destination service on which this policy is being applied.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyTlsMode
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple;

  /**
   * Represents the warmup duration of Service.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the number of a port on the destination service on which this policy is being applied.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

