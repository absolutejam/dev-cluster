// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema WorkloadGroup
 */
export class WorkloadGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkloadGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'WorkloadGroup',
  }

  /**
   * Renders a Kubernetes manifest for "WorkloadGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkloadGroupProps = {}): any {
    return {
      ...WorkloadGroup.GVK,
      ...toJson_WorkloadGroupProps(props),
    };
  }

  /**
   * Defines a "WorkloadGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkloadGroupProps = {}) {
    super(scope, id, {
      ...WorkloadGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkloadGroup.GVK,
      ...toJson_WorkloadGroupProps(resolved),
    };
  }
}

/**
 * @schema WorkloadGroup
 */
export interface WorkloadGroupProps {
  /**
   * @schema WorkloadGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
   *
   * @schema WorkloadGroup#spec
   */
  readonly spec?: WorkloadGroupSpec;

}

/**
 * Converts an object of type 'WorkloadGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupProps(obj: WorkloadGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkloadGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
 *
 * @schema WorkloadGroupSpec
 */
export interface WorkloadGroupSpec {
  /**
   * Metadata that will be used for all corresponding `WorkloadEntries`.
   *
   * @schema WorkloadGroupSpec#metadata
   */
  readonly metadata?: WorkloadGroupSpecMetadata;

  /**
   * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
   *
   * @schema WorkloadGroupSpec#probe
   */
  readonly probe?: WorkloadGroupSpecProbe;

  /**
   * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
   *
   * @schema WorkloadGroupSpec#template
   */
  readonly template: WorkloadGroupSpecTemplate;

}

/**
 * Converts an object of type 'WorkloadGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpec(obj: WorkloadGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_WorkloadGroupSpecMetadata(obj.metadata),
    'probe': toJson_WorkloadGroupSpecProbe(obj.probe),
    'template': toJson_WorkloadGroupSpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata that will be used for all corresponding `WorkloadEntries`.
 *
 * @schema WorkloadGroupSpecMetadata
 */
export interface WorkloadGroupSpecMetadata {
  /**
   * @schema WorkloadGroupSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema WorkloadGroupSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkloadGroupSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecMetadata(obj: WorkloadGroupSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
 *
 * @schema WorkloadGroupSpecProbe
 */
export interface WorkloadGroupSpecProbe {
  /**
   * Health is determined by how the command that is executed exited.
   *
   * @schema WorkloadGroupSpecProbe#exec
   */
  readonly exec?: WorkloadGroupSpecProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   *
   * @schema WorkloadGroupSpecProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * `httpGet` is performed to a given endpoint and the status/able to connect determines health.
   *
   * @schema WorkloadGroupSpecProbe#httpGet
   */
  readonly httpGet?: WorkloadGroupSpecProbeHttpGet;

  /**
   * Number of seconds after the container has started before readiness probes are initiated.
   *
   * @schema WorkloadGroupSpecProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   *
   * @schema WorkloadGroupSpecProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   *
   * @schema WorkloadGroupSpecProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * Health is determined by if the proxy is able to connect.
   *
   * @schema WorkloadGroupSpecProbe#tcpSocket
   */
  readonly tcpSocket?: WorkloadGroupSpecProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out.
   *
   * @schema WorkloadGroupSpecProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'WorkloadGroupSpecProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecProbe(obj: WorkloadGroupSpecProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_WorkloadGroupSpecProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'httpGet': toJson_WorkloadGroupSpecProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_WorkloadGroupSpecProbeTcpSocket(obj.tcpSocket),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
 *
 * @schema WorkloadGroupSpecTemplate
 */
export interface WorkloadGroupSpecTemplate {
  /**
   * Address associated with the network endpoint without the port.
   *
   * @schema WorkloadGroupSpecTemplate#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#locality
   */
  readonly locality?: string;

  /**
   * Network enables Istio to group endpoints resident in the same L3 domain/network.
   *
   * @schema WorkloadGroupSpecTemplate#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * The service account associated with the workload if a sidecar is present in the workload.
   *
   * @schema WorkloadGroupSpecTemplate#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'WorkloadGroupSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecTemplate(obj: WorkloadGroupSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locality': obj.locality,
    'network': obj.network,
    'ports': ((obj.ports) === undefined) ? undefined : (Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceAccount': obj.serviceAccount,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health is determined by how the command that is executed exited.
 *
 * @schema WorkloadGroupSpecProbeExec
 */
export interface WorkloadGroupSpecProbeExec {
  /**
   * Command to run.
   *
   * @schema WorkloadGroupSpecProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecProbeExec(obj: WorkloadGroupSpecProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `httpGet` is performed to a given endpoint and the status/able to connect determines health.
 *
 * @schema WorkloadGroupSpecProbeHttpGet
 */
export interface WorkloadGroupSpecProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Headers the proxy will pass on to make the request.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: WorkloadGroupSpecProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Port on which the endpoint lives.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#port
   */
  readonly port: number;

  /**
   * @schema WorkloadGroupSpecProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecProbeHttpGet(obj: WorkloadGroupSpecProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_WorkloadGroupSpecProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health is determined by if the proxy is able to connect.
 *
 * @schema WorkloadGroupSpecProbeTcpSocket
 */
export interface WorkloadGroupSpecProbeTcpSocket {
  /**
   * @schema WorkloadGroupSpecProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema WorkloadGroupSpecProbeTcpSocket#port
   */
  readonly port: number;

}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecProbeTcpSocket(obj: WorkloadGroupSpecProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkloadGroupSpecProbeHttpGetHttpHeaders
 */
export interface WorkloadGroupSpecProbeHttpGetHttpHeaders {
  /**
   * @schema WorkloadGroupSpecProbeHttpGetHttpHeaders#name
   */
  readonly name?: string;

  /**
   * @schema WorkloadGroupSpecProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecProbeHttpGetHttpHeaders(obj: WorkloadGroupSpecProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema WorkloadGroupV1Beta1
 */
export class WorkloadGroupV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkloadGroupV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'WorkloadGroup',
  }

  /**
   * Renders a Kubernetes manifest for "WorkloadGroupV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkloadGroupV1Beta1Props = {}): any {
    return {
      ...WorkloadGroupV1Beta1.GVK,
      ...toJson_WorkloadGroupV1Beta1Props(props),
    };
  }

  /**
   * Defines a "WorkloadGroupV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkloadGroupV1Beta1Props = {}) {
    super(scope, id, {
      ...WorkloadGroupV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkloadGroupV1Beta1.GVK,
      ...toJson_WorkloadGroupV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema WorkloadGroupV1Beta1
 */
export interface WorkloadGroupV1Beta1Props {
  /**
   * @schema WorkloadGroupV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * `WorkloadGroup` enables specifying the properties of a single workload for bootstrap and provides a template for `WorkloadEntry`, similar to how `Deployment` specifies properties of workloads via `Pod` templates.
   *
   * @schema WorkloadGroupV1Beta1#spec
   */
  readonly spec?: WorkloadGroupV1Beta1Spec;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupV1Beta1Props(obj: WorkloadGroupV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkloadGroupV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `WorkloadGroup` enables specifying the properties of a single workload for bootstrap and provides a template for `WorkloadEntry`, similar to how `Deployment` specifies properties of workloads via `Pod` templates.
 *
 * @schema WorkloadGroupV1Beta1Spec
 */
export interface WorkloadGroupV1Beta1Spec {
  /**
   * Metadata that will be used for all corresponding `WorkloadEntries`.
   *
   * @schema WorkloadGroupV1Beta1Spec#metadata
   */
  readonly metadata?: WorkloadGroupV1Beta1SpecMetadata;

  /**
   * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
   *
   * @schema WorkloadGroupV1Beta1Spec#probe
   */
  readonly probe?: WorkloadGroupV1Beta1SpecProbe;

  /**
   * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
   *
   * @schema WorkloadGroupV1Beta1Spec#template
   */
  readonly template: WorkloadGroupV1Beta1SpecTemplate;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupV1Beta1Spec(obj: WorkloadGroupV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_WorkloadGroupV1Beta1SpecMetadata(obj.metadata),
    'probe': toJson_WorkloadGroupV1Beta1SpecProbe(obj.probe),
    'template': toJson_WorkloadGroupV1Beta1SpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata that will be used for all corresponding `WorkloadEntries`.
 *
 * @schema WorkloadGroupV1Beta1SpecMetadata
 */
export interface WorkloadGroupV1Beta1SpecMetadata {
  /**
   * @schema WorkloadGroupV1Beta1SpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema WorkloadGroupV1Beta1SpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupV1Beta1SpecMetadata(obj: WorkloadGroupV1Beta1SpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
 *
 * @schema WorkloadGroupV1Beta1SpecProbe
 */
export interface WorkloadGroupV1Beta1SpecProbe {
  /**
   * Health is determined by how the command that is executed exited.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#exec
   */
  readonly exec?: WorkloadGroupV1Beta1SpecProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * `httpGet` is performed to a given endpoint and the status/able to connect determines health.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#httpGet
   */
  readonly httpGet?: WorkloadGroupV1Beta1SpecProbeHttpGet;

  /**
   * Number of seconds after the container has started before readiness probes are initiated.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * Health is determined by if the proxy is able to connect.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#tcpSocket
   */
  readonly tcpSocket?: WorkloadGroupV1Beta1SpecProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupV1Beta1SpecProbe(obj: WorkloadGroupV1Beta1SpecProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_WorkloadGroupV1Beta1SpecProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'httpGet': toJson_WorkloadGroupV1Beta1SpecProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_WorkloadGroupV1Beta1SpecProbeTcpSocket(obj.tcpSocket),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
 *
 * @schema WorkloadGroupV1Beta1SpecTemplate
 */
export interface WorkloadGroupV1Beta1SpecTemplate {
  /**
   * Address associated with the network endpoint without the port.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#locality
   */
  readonly locality?: string;

  /**
   * Network enables Istio to group endpoints resident in the same L3 domain/network.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * The service account associated with the workload if a sidecar is present in the workload.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupV1Beta1SpecTemplate(obj: WorkloadGroupV1Beta1SpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locality': obj.locality,
    'network': obj.network,
    'ports': ((obj.ports) === undefined) ? undefined : (Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceAccount': obj.serviceAccount,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health is determined by how the command that is executed exited.
 *
 * @schema WorkloadGroupV1Beta1SpecProbeExec
 */
export interface WorkloadGroupV1Beta1SpecProbeExec {
  /**
   * Command to run.
   *
   * @schema WorkloadGroupV1Beta1SpecProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupV1Beta1SpecProbeExec(obj: WorkloadGroupV1Beta1SpecProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `httpGet` is performed to a given endpoint and the status/able to connect determines health.
 *
 * @schema WorkloadGroupV1Beta1SpecProbeHttpGet
 */
export interface WorkloadGroupV1Beta1SpecProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP.
   *
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Headers the proxy will pass on to make the request.
   *
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Port on which the endpoint lives.
   *
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGet#port
   */
  readonly port: number;

  /**
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupV1Beta1SpecProbeHttpGet(obj: WorkloadGroupV1Beta1SpecProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health is determined by if the proxy is able to connect.
 *
 * @schema WorkloadGroupV1Beta1SpecProbeTcpSocket
 */
export interface WorkloadGroupV1Beta1SpecProbeTcpSocket {
  /**
   * @schema WorkloadGroupV1Beta1SpecProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema WorkloadGroupV1Beta1SpecProbeTcpSocket#port
   */
  readonly port: number;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupV1Beta1SpecProbeTcpSocket(obj: WorkloadGroupV1Beta1SpecProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders
 */
export interface WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders {
  /**
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders#name
   */
  readonly name?: string;

  /**
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders(obj: WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

