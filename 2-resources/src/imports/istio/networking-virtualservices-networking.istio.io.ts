// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema VirtualService
 */
export class VirtualService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'VirtualService',
  }

  /**
   * Renders a Kubernetes manifest for "VirtualService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualServiceProps = {}): any {
    return {
      ...VirtualService.GVK,
      ...toJson_VirtualServiceProps(props),
    };
  }

  /**
   * Defines a "VirtualService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualServiceProps = {}) {
    super(scope, id, {
      ...VirtualService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualService.GVK,
      ...toJson_VirtualServiceProps(resolved),
    };
  }
}

/**
 * @schema VirtualService
 */
export interface VirtualServiceProps {
  /**
   * @schema VirtualService#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
   *
   * @schema VirtualService#spec
   */
  readonly spec?: VirtualServiceSpec;

}

/**
 * Converts an object of type 'VirtualServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceProps(obj: VirtualServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VirtualServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
 *
 * @schema VirtualServiceSpec
 */
export interface VirtualServiceSpec {
  /**
   * A list of namespaces to which this virtual service is exported.
   *
   * @schema VirtualServiceSpec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The names of gateways and sidecars that should apply these routes.
   *
   * @schema VirtualServiceSpec#gateways
   */
  readonly gateways?: string[];

  /**
   * The destination hosts to which traffic is being sent.
   *
   * @schema VirtualServiceSpec#hosts
   */
  readonly hosts?: string[];

  /**
   * An ordered list of route rules for HTTP traffic.
   *
   * @schema VirtualServiceSpec#http
   */
  readonly http?: VirtualServiceSpecHttp[];

  /**
   * An ordered list of route rules for opaque TCP traffic.
   *
   * @schema VirtualServiceSpec#tcp
   */
  readonly tcp?: VirtualServiceSpecTcp[];

  /**
   * An ordered list of route rule for non-terminated TLS & HTTPS traffic.
   *
   * @schema VirtualServiceSpec#tls
   */
  readonly tls?: VirtualServiceSpecTls[];

}

/**
 * Converts an object of type 'VirtualServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpec(obj: VirtualServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportTo': obj.exportTo?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'hosts': obj.hosts?.map(y => y),
    'http': obj.http?.map(y => toJson_VirtualServiceSpecHttp(y)),
    'tcp': obj.tcp?.map(y => toJson_VirtualServiceSpecTcp(y)),
    'tls': obj.tls?.map(y => toJson_VirtualServiceSpecTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttp
 */
export interface VirtualServiceSpecHttp {
  /**
   * Cross-Origin Resource Sharing policy (CORS).
   *
   * @schema VirtualServiceSpecHttp#corsPolicy
   */
  readonly corsPolicy?: VirtualServiceSpecHttpCorsPolicy;

  /**
   * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
   *
   * @schema VirtualServiceSpecHttp#delegate
   */
  readonly delegate?: VirtualServiceSpecHttpDelegate;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceSpecHttp#directResponse
   */
  readonly directResponse?: VirtualServiceSpecHttpDirectResponse;

  /**
   * Fault injection policy to apply on HTTP traffic at the client side.
   *
   * @schema VirtualServiceSpecHttp#fault
   */
  readonly fault?: VirtualServiceSpecHttpFault;

  /**
   * @schema VirtualServiceSpecHttp#headers
   */
  readonly headers?: VirtualServiceSpecHttpHeaders;

  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceSpecHttp#match
   */
  readonly match?: VirtualServiceSpecHttpMatch[];

  /**
   * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
   *
   * @schema VirtualServiceSpecHttp#mirror
   */
  readonly mirror?: VirtualServiceSpecHttpMirror;

  /**
   * @schema VirtualServiceSpecHttp#mirror_percent
   */
  readonly mirrorPercent?: number;

  /**
   * @schema VirtualServiceSpecHttp#mirrorPercent
   */
  readonly mirror_percent?: number;

  /**
   * Percentage of the traffic to be mirrored by the `mirror` field.
   *
   * @schema VirtualServiceSpecHttp#mirrorPercentage
   */
  readonly mirrorPercentage?: VirtualServiceSpecHttpMirrorPercentage;

  /**
   * Specifies the destinations to mirror HTTP traffic in addition to the original destination.
   *
   * @schema VirtualServiceSpecHttp#mirrors
   */
  readonly mirrors?: VirtualServiceSpecHttpMirrors[];

  /**
   * The name assigned to the route for debugging purposes.
   *
   * @schema VirtualServiceSpecHttp#name
   */
  readonly name?: string;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceSpecHttp#redirect
   */
  readonly redirect?: VirtualServiceSpecHttpRedirect;

  /**
   * Retry policy for HTTP requests.
   *
   * @schema VirtualServiceSpecHttp#retries
   */
  readonly retries?: VirtualServiceSpecHttpRetries;

  /**
   * Rewrite HTTP URIs and Authority headers.
   *
   * @schema VirtualServiceSpecHttp#rewrite
   */
  readonly rewrite?: VirtualServiceSpecHttpRewrite;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceSpecHttp#route
   */
  readonly route?: VirtualServiceSpecHttpRoute[];

  /**
   * Timeout for HTTP requests, default is disabled.
   *
   * @schema VirtualServiceSpecHttp#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttp(obj: VirtualServiceSpecHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsPolicy': toJson_VirtualServiceSpecHttpCorsPolicy(obj.corsPolicy),
    'delegate': toJson_VirtualServiceSpecHttpDelegate(obj.delegate),
    'directResponse': toJson_VirtualServiceSpecHttpDirectResponse(obj.directResponse),
    'fault': toJson_VirtualServiceSpecHttpFault(obj.fault),
    'headers': toJson_VirtualServiceSpecHttpHeaders(obj.headers),
    'match': obj.match?.map(y => toJson_VirtualServiceSpecHttpMatch(y)),
    'mirror': toJson_VirtualServiceSpecHttpMirror(obj.mirror),
    'mirror_percent': obj.mirrorPercent,
    'mirrorPercent': obj.mirrorPercent,
    'mirrorPercentage': toJson_VirtualServiceSpecHttpMirrorPercentage(obj.mirrorPercentage),
    'mirrors': obj.mirrors?.map(y => toJson_VirtualServiceSpecHttpMirrors(y)),
    'name': obj.name,
    'redirect': toJson_VirtualServiceSpecHttpRedirect(obj.redirect),
    'retries': toJson_VirtualServiceSpecHttpRetries(obj.retries),
    'rewrite': toJson_VirtualServiceSpecHttpRewrite(obj.rewrite),
    'route': obj.route?.map(y => toJson_VirtualServiceSpecHttpRoute(y)),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTcp
 */
export interface VirtualServiceSpecTcp {
  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceSpecTcp#match
   */
  readonly match?: VirtualServiceSpecTcpMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceSpecTcp#route
   */
  readonly route?: VirtualServiceSpecTcpRoute[];

}

/**
 * Converts an object of type 'VirtualServiceSpecTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTcp(obj: VirtualServiceSpecTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualServiceSpecTcpMatch(y)),
    'route': obj.route?.map(y => toJson_VirtualServiceSpecTcpRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTls
 */
export interface VirtualServiceSpecTls {
  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceSpecTls#match
   */
  readonly match: VirtualServiceSpecTlsMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceSpecTls#route
   */
  readonly route?: VirtualServiceSpecTlsRoute[];

}

/**
 * Converts an object of type 'VirtualServiceSpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTls(obj: VirtualServiceSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualServiceSpecTlsMatch(y)),
    'route': obj.route?.map(y => toJson_VirtualServiceSpecTlsRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cross-Origin Resource Sharing policy (CORS).
 *
 * @schema VirtualServiceSpecHttpCorsPolicy
 */
export interface VirtualServiceSpecHttpCorsPolicy {
  /**
   * Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * List of HTTP headers that can be used when requesting the resource.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * List of HTTP methods allowed to access the resource.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * @schema VirtualServiceSpecHttpCorsPolicy#allowOrigin
   */
  readonly allowOrigin?: string[];

  /**
   * String patterns that match allowed origins.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#allowOrigins
   */
  readonly allowOrigins?: VirtualServiceSpecHttpCorsPolicyAllowOrigins[];

  /**
   * A list of HTTP headers that the browsers are allowed to access.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Specifies how long the results of a preflight request can be cached.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#maxAge
   */
  readonly maxAge?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpCorsPolicy(obj: VirtualServiceSpecHttpCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigin': obj.allowOrigin?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => toJson_VirtualServiceSpecHttpCorsPolicyAllowOrigins(y)),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
 *
 * @schema VirtualServiceSpecHttpDelegate
 */
export interface VirtualServiceSpecHttpDelegate {
  /**
   * Name specifies the name of the delegate VirtualService.
   *
   * @schema VirtualServiceSpecHttpDelegate#name
   */
  readonly name?: string;

  /**
   * Namespace specifies the namespace where the delegate VirtualService resides.
   *
   * @schema VirtualServiceSpecHttpDelegate#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpDelegate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpDelegate(obj: VirtualServiceSpecHttpDelegate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 *
 * @schema VirtualServiceSpecHttpDirectResponse
 */
export interface VirtualServiceSpecHttpDirectResponse {
  /**
   * Specifies the content of the response body.
   *
   * @schema VirtualServiceSpecHttpDirectResponse#body
   */
  readonly body?: VirtualServiceSpecHttpDirectResponseBody;

  /**
   * Specifies the HTTP response status to be returned.
   *
   * @schema VirtualServiceSpecHttpDirectResponse#status
   */
  readonly status: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpDirectResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpDirectResponse(obj: VirtualServiceSpecHttpDirectResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': toJson_VirtualServiceSpecHttpDirectResponseBody(obj.body),
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fault injection policy to apply on HTTP traffic at the client side.
 *
 * @schema VirtualServiceSpecHttpFault
 */
export interface VirtualServiceSpecHttpFault {
  /**
   * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
   *
   * @schema VirtualServiceSpecHttpFault#abort
   */
  readonly abort?: VirtualServiceSpecHttpFaultAbort;

  /**
   * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
   *
   * @schema VirtualServiceSpecHttpFault#delay
   */
  readonly delay?: VirtualServiceSpecHttpFaultDelay;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpFault(obj: VirtualServiceSpecHttpFault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_VirtualServiceSpecHttpFaultAbort(obj.abort),
    'delay': toJson_VirtualServiceSpecHttpFaultDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpHeaders
 */
export interface VirtualServiceSpecHttpHeaders {
  /**
   * @schema VirtualServiceSpecHttpHeaders#request
   */
  readonly request?: VirtualServiceSpecHttpHeadersRequest;

  /**
   * @schema VirtualServiceSpecHttpHeaders#response
   */
  readonly response?: VirtualServiceSpecHttpHeadersResponse;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpHeaders(obj: VirtualServiceSpecHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_VirtualServiceSpecHttpHeadersRequest(obj.request),
    'response': toJson_VirtualServiceSpecHttpHeadersResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatch
 */
export interface VirtualServiceSpecHttpMatch {
  /**
   * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatch#authority
   */
  readonly authority?: VirtualServiceSpecHttpMatchAuthority;

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceSpecHttpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * The header keys must be lowercase and use hyphen as the separator, e.g.
   *
   * @schema VirtualServiceSpecHttpMatch#headers
   */
  readonly headers?: { [key: string]: VirtualServiceSpecHttpMatchHeaders };

  /**
   * Flag to specify whether the URI matching should be case-insensitive.
   *
   * @schema VirtualServiceSpecHttpMatch#ignoreUriCase
   */
  readonly ignoreUriCase?: boolean;

  /**
   * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatch#method
   */
  readonly method?: VirtualServiceSpecHttpMatchMethod;

  /**
   * The name assigned to a match.
   *
   * @schema VirtualServiceSpecHttpMatch#name
   */
  readonly name?: string;

  /**
   * Specifies the ports on the host that is being addressed.
   *
   * @schema VirtualServiceSpecHttpMatch#port
   */
  readonly port?: number;

  /**
   * Query parameters for matching.
   *
   * @schema VirtualServiceSpecHttpMatch#queryParams
   */
  readonly queryParams?: { [key: string]: VirtualServiceSpecHttpMatchQueryParams };

  /**
   * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatch#scheme
   */
  readonly scheme?: VirtualServiceSpecHttpMatchScheme;

  /**
   * One or more labels that constrain the applicability of a rule to source (client) workloads with the given labels.
   *
   * @schema VirtualServiceSpecHttpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceSpecHttpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * The human readable prefix to use when emitting statistics for this route.
   *
   * @schema VirtualServiceSpecHttpMatch#statPrefix
   */
  readonly statPrefix?: string;

  /**
   * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatch#uri
   */
  readonly uri?: VirtualServiceSpecHttpMatchUri;

  /**
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   *
   * @schema VirtualServiceSpecHttpMatch#withoutHeaders
   */
  readonly withoutHeaders?: { [key: string]: VirtualServiceSpecHttpMatchWithoutHeaders };

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatch(obj: VirtualServiceSpecHttpMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': toJson_VirtualServiceSpecHttpMatchAuthority(obj.authority),
    'gateways': obj.gateways?.map(y => y),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceSpecHttpMatchHeaders(i[1]) }), {})),
    'ignoreUriCase': obj.ignoreUriCase,
    'method': toJson_VirtualServiceSpecHttpMatchMethod(obj.method),
    'name': obj.name,
    'port': obj.port,
    'queryParams': ((obj.queryParams) === undefined) ? undefined : (Object.entries(obj.queryParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceSpecHttpMatchQueryParams(i[1]) }), {})),
    'scheme': toJson_VirtualServiceSpecHttpMatchScheme(obj.scheme),
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
    'statPrefix': obj.statPrefix,
    'uri': toJson_VirtualServiceSpecHttpMatchUri(obj.uri),
    'withoutHeaders': ((obj.withoutHeaders) === undefined) ? undefined : (Object.entries(obj.withoutHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceSpecHttpMatchWithoutHeaders(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
 *
 * @schema VirtualServiceSpecHttpMirror
 */
export interface VirtualServiceSpecHttpMirror {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecHttpMirror#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecHttpMirror#port
   */
  readonly port?: VirtualServiceSpecHttpMirrorPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecHttpMirror#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirror' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMirror(obj: VirtualServiceSpecHttpMirror | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceSpecHttpMirrorPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of the traffic to be mirrored by the `mirror` field.
 *
 * @schema VirtualServiceSpecHttpMirrorPercentage
 */
export interface VirtualServiceSpecHttpMirrorPercentage {
  /**
   * @schema VirtualServiceSpecHttpMirrorPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMirrorPercentage(obj: VirtualServiceSpecHttpMirrorPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMirrors
 */
export interface VirtualServiceSpecHttpMirrors {
  /**
   * Destination specifies the target of the mirror operation.
   *
   * @schema VirtualServiceSpecHttpMirrors#destination
   */
  readonly destination: VirtualServiceSpecHttpMirrorsDestination;

  /**
   * Percentage of the traffic to be mirrored by the `destination` field.
   *
   * @schema VirtualServiceSpecHttpMirrors#percentage
   */
  readonly percentage?: VirtualServiceSpecHttpMirrorsPercentage;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMirrors(obj: VirtualServiceSpecHttpMirrors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceSpecHttpMirrorsDestination(obj.destination),
    'percentage': toJson_VirtualServiceSpecHttpMirrorsPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 *
 * @schema VirtualServiceSpecHttpRedirect
 */
export interface VirtualServiceSpecHttpRedirect {
  /**
   * On a redirect, overwrite the Authority/Host portion of the URL with this value.
   *
   * @schema VirtualServiceSpecHttpRedirect#authority
   */
  readonly authority?: string;

  /**
   * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.
   *
   * @schema VirtualServiceSpecHttpRedirect#derivePort
   */
  readonly derivePort?: VirtualServiceSpecHttpRedirectDerivePort;

  /**
   * On a redirect, overwrite the port portion of the URL with this value.
   *
   * @schema VirtualServiceSpecHttpRedirect#port
   */
  readonly port?: number;

  /**
   * On a redirect, Specifies the HTTP status code to use in the redirect response.
   *
   * @schema VirtualServiceSpecHttpRedirect#redirectCode
   */
  readonly redirectCode?: number;

  /**
   * On a redirect, overwrite the scheme portion of the URL with this value.
   *
   * @schema VirtualServiceSpecHttpRedirect#scheme
   */
  readonly scheme?: string;

  /**
   * On a redirect, overwrite the Path portion of the URL with this value.
   *
   * @schema VirtualServiceSpecHttpRedirect#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRedirect(obj: VirtualServiceSpecHttpRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': obj.authority,
    'derivePort': obj.derivePort,
    'port': obj.port,
    'redirectCode': obj.redirectCode,
    'scheme': obj.scheme,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Retry policy for HTTP requests.
 *
 * @schema VirtualServiceSpecHttpRetries
 */
export interface VirtualServiceSpecHttpRetries {
  /**
   * Number of retries to be allowed for a given request.
   *
   * @schema VirtualServiceSpecHttpRetries#attempts
   */
  readonly attempts?: number;

  /**
   * Timeout per attempt for a given request, including the initial call and any retries.
   *
   * @schema VirtualServiceSpecHttpRetries#perTryTimeout
   */
  readonly perTryTimeout?: string;

  /**
   * Specifies the conditions under which retry takes place.
   *
   * @schema VirtualServiceSpecHttpRetries#retryOn
   */
  readonly retryOn?: string;

  /**
   * Flag to specify whether the retries should retry to other localities.
   *
   * @schema VirtualServiceSpecHttpRetries#retryRemoteLocalities
   */
  readonly retryRemoteLocalities?: boolean;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRetries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRetries(obj: VirtualServiceSpecHttpRetries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attempts': obj.attempts,
    'perTryTimeout': obj.perTryTimeout,
    'retryOn': obj.retryOn,
    'retryRemoteLocalities': obj.retryRemoteLocalities,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rewrite HTTP URIs and Authority headers.
 *
 * @schema VirtualServiceSpecHttpRewrite
 */
export interface VirtualServiceSpecHttpRewrite {
  /**
   * rewrite the Authority/Host header with this value.
   *
   * @schema VirtualServiceSpecHttpRewrite#authority
   */
  readonly authority?: string;

  /**
   * rewrite the path (or the prefix) portion of the URI with this value.
   *
   * @schema VirtualServiceSpecHttpRewrite#uri
   */
  readonly uri?: string;

  /**
   * rewrite the path portion of the URI with the specified regex.
   *
   * @schema VirtualServiceSpecHttpRewrite#uriRegexRewrite
   */
  readonly uriRegexRewrite?: VirtualServiceSpecHttpRewriteUriRegexRewrite;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRewrite(obj: VirtualServiceSpecHttpRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': obj.authority,
    'uri': obj.uri,
    'uriRegexRewrite': toJson_VirtualServiceSpecHttpRewriteUriRegexRewrite(obj.uriRegexRewrite),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpRoute
 */
export interface VirtualServiceSpecHttpRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceSpecHttpRoute#destination
   */
  readonly destination: VirtualServiceSpecHttpRouteDestination;

  /**
   * @schema VirtualServiceSpecHttpRoute#headers
   */
  readonly headers?: VirtualServiceSpecHttpRouteHeaders;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceSpecHttpRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRoute(obj: VirtualServiceSpecHttpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceSpecHttpRouteDestination(obj.destination),
    'headers': toJson_VirtualServiceSpecHttpRouteHeaders(obj.headers),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTcpMatch
 */
export interface VirtualServiceSpecTcpMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceSpecTcpMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceSpecTcpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTcpMatch#port
   */
  readonly port?: number;

  /**
   * One or more labels that constrain the applicability of a rule to workloads with the given labels.
   *
   * @schema VirtualServiceSpecTcpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceSpecTcpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * @schema VirtualServiceSpecTcpMatch#sourceSubnet
   */
  readonly sourceSubnet?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecTcpMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTcpMatch(obj: VirtualServiceSpecTcpMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSubnets': obj.destinationSubnets?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'port': obj.port,
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
    'sourceSubnet': obj.sourceSubnet,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTcpRoute
 */
export interface VirtualServiceSpecTcpRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceSpecTcpRoute#destination
   */
  readonly destination: VirtualServiceSpecTcpRouteDestination;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceSpecTcpRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecTcpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTcpRoute(obj: VirtualServiceSpecTcpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceSpecTcpRouteDestination(obj.destination),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTlsMatch
 */
export interface VirtualServiceSpecTlsMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceSpecTlsMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceSpecTlsMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTlsMatch#port
   */
  readonly port?: number;

  /**
   * SNI (server name indicator) to match on.
   *
   * @schema VirtualServiceSpecTlsMatch#sniHosts
   */
  readonly sniHosts: string[];

  /**
   * One or more labels that constrain the applicability of a rule to workloads with the given labels.
   *
   * @schema VirtualServiceSpecTlsMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceSpecTlsMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecTlsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTlsMatch(obj: VirtualServiceSpecTlsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSubnets': obj.destinationSubnets?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'port': obj.port,
    'sniHosts': obj.sniHosts?.map(y => y),
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTlsRoute
 */
export interface VirtualServiceSpecTlsRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceSpecTlsRoute#destination
   */
  readonly destination: VirtualServiceSpecTlsRouteDestination;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceSpecTlsRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecTlsRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTlsRoute(obj: VirtualServiceSpecTlsRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceSpecTlsRouteDestination(obj.destination),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins
 */
export interface VirtualServiceSpecHttpCorsPolicyAllowOrigins {
  /**
   * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpCorsPolicyAllowOrigins' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpCorsPolicyAllowOrigins(obj: VirtualServiceSpecHttpCorsPolicyAllowOrigins | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the content of the response body.
 *
 * @schema VirtualServiceSpecHttpDirectResponseBody
 */
export interface VirtualServiceSpecHttpDirectResponseBody {
  /**
   * response body as base64 encoded bytes.
   *
   * @schema VirtualServiceSpecHttpDirectResponseBody#bytes
   */
  readonly bytes?: string;

  /**
   * @schema VirtualServiceSpecHttpDirectResponseBody#string
   */
  readonly string?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpDirectResponseBody' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpDirectResponseBody(obj: VirtualServiceSpecHttpDirectResponseBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bytes': obj.bytes,
    'string': obj.string,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
 *
 * @schema VirtualServiceSpecHttpFaultAbort
 */
export interface VirtualServiceSpecHttpFaultAbort {
  /**
   * GRPC status code to use to abort the request.
   *
   * @schema VirtualServiceSpecHttpFaultAbort#grpcStatus
   */
  readonly grpcStatus?: string;

  /**
   * @schema VirtualServiceSpecHttpFaultAbort#http2Error
   */
  readonly http2Error?: string;

  /**
   * HTTP status code to use to abort the Http request.
   *
   * @schema VirtualServiceSpecHttpFaultAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * Percentage of requests to be aborted with the error code provided.
   *
   * @schema VirtualServiceSpecHttpFaultAbort#percentage
   */
  readonly percentage?: VirtualServiceSpecHttpFaultAbortPercentage;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultAbort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpFaultAbort(obj: VirtualServiceSpecHttpFaultAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcStatus': obj.grpcStatus,
    'http2Error': obj.http2Error,
    'httpStatus': obj.httpStatus,
    'percentage': toJson_VirtualServiceSpecHttpFaultAbortPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
 *
 * @schema VirtualServiceSpecHttpFaultDelay
 */
export interface VirtualServiceSpecHttpFaultDelay {
  /**
   * @schema VirtualServiceSpecHttpFaultDelay#exponentialDelay
   */
  readonly exponentialDelay?: string;

  /**
   * Add a fixed delay before forwarding the request.
   *
   * @schema VirtualServiceSpecHttpFaultDelay#fixedDelay
   */
  readonly fixedDelay?: string;

  /**
   * Percentage of requests on which the delay will be injected (0-100).
   *
   * @schema VirtualServiceSpecHttpFaultDelay#percent
   */
  readonly percent?: number;

  /**
   * Percentage of requests on which the delay will be injected.
   *
   * @schema VirtualServiceSpecHttpFaultDelay#percentage
   */
  readonly percentage?: VirtualServiceSpecHttpFaultDelayPercentage;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpFaultDelay(obj: VirtualServiceSpecHttpFaultDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exponentialDelay': obj.exponentialDelay,
    'fixedDelay': obj.fixedDelay,
    'percent': obj.percent,
    'percentage': toJson_VirtualServiceSpecHttpFaultDelayPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpHeadersRequest
 */
export interface VirtualServiceSpecHttpHeadersRequest {
  /**
   * @schema VirtualServiceSpecHttpHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpHeadersRequest#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpHeadersRequest(obj: VirtualServiceSpecHttpHeadersRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpHeadersResponse
 */
export interface VirtualServiceSpecHttpHeadersResponse {
  /**
   * @schema VirtualServiceSpecHttpHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpHeadersResponse#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpHeadersResponse(obj: VirtualServiceSpecHttpHeadersResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceSpecHttpMatchAuthority
 */
export interface VirtualServiceSpecHttpMatchAuthority {
  /**
   * @schema VirtualServiceSpecHttpMatchAuthority#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchAuthority#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchAuthority#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchAuthority' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchAuthority(obj: VirtualServiceSpecHttpMatchAuthority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchHeaders
 */
export interface VirtualServiceSpecHttpMatchHeaders {
  /**
   * @schema VirtualServiceSpecHttpMatchHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchHeaders#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchHeaders(obj: VirtualServiceSpecHttpMatchHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceSpecHttpMatchMethod
 */
export interface VirtualServiceSpecHttpMatchMethod {
  /**
   * @schema VirtualServiceSpecHttpMatchMethod#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchMethod#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchMethod#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchMethod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchMethod(obj: VirtualServiceSpecHttpMatchMethod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchQueryParams
 */
export interface VirtualServiceSpecHttpMatchQueryParams {
  /**
   * @schema VirtualServiceSpecHttpMatchQueryParams#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchQueryParams#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchQueryParams#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchQueryParams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchQueryParams(obj: VirtualServiceSpecHttpMatchQueryParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceSpecHttpMatchScheme
 */
export interface VirtualServiceSpecHttpMatchScheme {
  /**
   * @schema VirtualServiceSpecHttpMatchScheme#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchScheme#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchScheme#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchScheme' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchScheme(obj: VirtualServiceSpecHttpMatchScheme | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceSpecHttpMatchUri
 */
export interface VirtualServiceSpecHttpMatchUri {
  /**
   * @schema VirtualServiceSpecHttpMatchUri#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchUri#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchUri#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchUri' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchUri(obj: VirtualServiceSpecHttpMatchUri | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchWithoutHeaders
 */
export interface VirtualServiceSpecHttpMatchWithoutHeaders {
  /**
   * @schema VirtualServiceSpecHttpMatchWithoutHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchWithoutHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchWithoutHeaders#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchWithoutHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchWithoutHeaders(obj: VirtualServiceSpecHttpMatchWithoutHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecHttpMirrorPort
 */
export interface VirtualServiceSpecHttpMirrorPort {
  /**
   * @schema VirtualServiceSpecHttpMirrorPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMirrorPort(obj: VirtualServiceSpecHttpMirrorPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Destination specifies the target of the mirror operation.
 *
 * @schema VirtualServiceSpecHttpMirrorsDestination
 */
export interface VirtualServiceSpecHttpMirrorsDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecHttpMirrorsDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecHttpMirrorsDestination#port
   */
  readonly port?: VirtualServiceSpecHttpMirrorsDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecHttpMirrorsDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMirrorsDestination(obj: VirtualServiceSpecHttpMirrorsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceSpecHttpMirrorsDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of the traffic to be mirrored by the `destination` field.
 *
 * @schema VirtualServiceSpecHttpMirrorsPercentage
 */
export interface VirtualServiceSpecHttpMirrorsPercentage {
  /**
   * @schema VirtualServiceSpecHttpMirrorsPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorsPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMirrorsPercentage(obj: VirtualServiceSpecHttpMirrorsPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.
 *
 * @schema VirtualServiceSpecHttpRedirectDerivePort
 */
export enum VirtualServiceSpecHttpRedirectDerivePort {
  /** FROM_PROTOCOL_DEFAULT */
  FROM_UNDERSCORE_PROTOCOL_UNDERSCORE_DEFAULT = "FROM_PROTOCOL_DEFAULT",
  /** FROM_REQUEST_PORT */
  FROM_UNDERSCORE_REQUEST_UNDERSCORE_PORT = "FROM_REQUEST_PORT",
}

/**
 * rewrite the path portion of the URI with the specified regex.
 *
 * @schema VirtualServiceSpecHttpRewriteUriRegexRewrite
 */
export interface VirtualServiceSpecHttpRewriteUriRegexRewrite {
  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpRewriteUriRegexRewrite#match
   */
  readonly match?: string;

  /**
   * The string that should replace into matching portions of original URI.
   *
   * @schema VirtualServiceSpecHttpRewriteUriRegexRewrite#rewrite
   */
  readonly rewrite?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRewriteUriRegexRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRewriteUriRegexRewrite(obj: VirtualServiceSpecHttpRewriteUriRegexRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match,
    'rewrite': obj.rewrite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceSpecHttpRouteDestination
 */
export interface VirtualServiceSpecHttpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecHttpRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecHttpRouteDestination#port
   */
  readonly port?: VirtualServiceSpecHttpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecHttpRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRouteDestination(obj: VirtualServiceSpecHttpRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceSpecHttpRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpRouteHeaders
 */
export interface VirtualServiceSpecHttpRouteHeaders {
  /**
   * @schema VirtualServiceSpecHttpRouteHeaders#request
   */
  readonly request?: VirtualServiceSpecHttpRouteHeadersRequest;

  /**
   * @schema VirtualServiceSpecHttpRouteHeaders#response
   */
  readonly response?: VirtualServiceSpecHttpRouteHeadersResponse;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRouteHeaders(obj: VirtualServiceSpecHttpRouteHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_VirtualServiceSpecHttpRouteHeadersRequest(obj.request),
    'response': toJson_VirtualServiceSpecHttpRouteHeadersResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceSpecTcpRouteDestination
 */
export interface VirtualServiceSpecTcpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecTcpRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTcpRouteDestination#port
   */
  readonly port?: VirtualServiceSpecTcpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecTcpRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecTcpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTcpRouteDestination(obj: VirtualServiceSpecTcpRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceSpecTcpRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceSpecTlsRouteDestination
 */
export interface VirtualServiceSpecTlsRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecTlsRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTlsRouteDestination#port
   */
  readonly port?: VirtualServiceSpecTlsRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecTlsRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecTlsRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTlsRouteDestination(obj: VirtualServiceSpecTlsRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceSpecTlsRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of requests to be aborted with the error code provided.
 *
 * @schema VirtualServiceSpecHttpFaultAbortPercentage
 */
export interface VirtualServiceSpecHttpFaultAbortPercentage {
  /**
   * @schema VirtualServiceSpecHttpFaultAbortPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultAbortPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpFaultAbortPercentage(obj: VirtualServiceSpecHttpFaultAbortPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of requests on which the delay will be injected.
 *
 * @schema VirtualServiceSpecHttpFaultDelayPercentage
 */
export interface VirtualServiceSpecHttpFaultDelayPercentage {
  /**
   * @schema VirtualServiceSpecHttpFaultDelayPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultDelayPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpFaultDelayPercentage(obj: VirtualServiceSpecHttpFaultDelayPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecHttpMirrorsDestinationPort
 */
export interface VirtualServiceSpecHttpMirrorsDestinationPort {
  /**
   * @schema VirtualServiceSpecHttpMirrorsDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorsDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMirrorsDestinationPort(obj: VirtualServiceSpecHttpMirrorsDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecHttpRouteDestinationPort
 */
export interface VirtualServiceSpecHttpRouteDestinationPort {
  /**
   * @schema VirtualServiceSpecHttpRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRouteDestinationPort(obj: VirtualServiceSpecHttpRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpRouteHeadersRequest
 */
export interface VirtualServiceSpecHttpRouteHeadersRequest {
  /**
   * @schema VirtualServiceSpecHttpRouteHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersRequest#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRouteHeadersRequest(obj: VirtualServiceSpecHttpRouteHeadersRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpRouteHeadersResponse
 */
export interface VirtualServiceSpecHttpRouteHeadersResponse {
  /**
   * @schema VirtualServiceSpecHttpRouteHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersResponse#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRouteHeadersResponse(obj: VirtualServiceSpecHttpRouteHeadersResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecTcpRouteDestinationPort
 */
export interface VirtualServiceSpecTcpRouteDestinationPort {
  /**
   * @schema VirtualServiceSpecTcpRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecTcpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTcpRouteDestinationPort(obj: VirtualServiceSpecTcpRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecTlsRouteDestinationPort
 */
export interface VirtualServiceSpecTlsRouteDestinationPort {
  /**
   * @schema VirtualServiceSpecTlsRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecTlsRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTlsRouteDestinationPort(obj: VirtualServiceSpecTlsRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema VirtualServiceV1Beta1
 */
export class VirtualServiceV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualServiceV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'VirtualService',
  }

  /**
   * Renders a Kubernetes manifest for "VirtualServiceV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualServiceV1Beta1Props = {}): any {
    return {
      ...VirtualServiceV1Beta1.GVK,
      ...toJson_VirtualServiceV1Beta1Props(props),
    };
  }

  /**
   * Defines a "VirtualServiceV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualServiceV1Beta1Props = {}) {
    super(scope, id, {
      ...VirtualServiceV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualServiceV1Beta1.GVK,
      ...toJson_VirtualServiceV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema VirtualServiceV1Beta1
 */
export interface VirtualServiceV1Beta1Props {
  /**
   * @schema VirtualServiceV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
   *
   * @schema VirtualServiceV1Beta1#spec
   */
  readonly spec?: VirtualServiceV1Beta1Spec;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1Props(obj: VirtualServiceV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VirtualServiceV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
 *
 * @schema VirtualServiceV1Beta1Spec
 */
export interface VirtualServiceV1Beta1Spec {
  /**
   * A list of namespaces to which this virtual service is exported.
   *
   * @schema VirtualServiceV1Beta1Spec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The names of gateways and sidecars that should apply these routes.
   *
   * @schema VirtualServiceV1Beta1Spec#gateways
   */
  readonly gateways?: string[];

  /**
   * The destination hosts to which traffic is being sent.
   *
   * @schema VirtualServiceV1Beta1Spec#hosts
   */
  readonly hosts?: string[];

  /**
   * An ordered list of route rules for HTTP traffic.
   *
   * @schema VirtualServiceV1Beta1Spec#http
   */
  readonly http?: VirtualServiceV1Beta1SpecHttp[];

  /**
   * An ordered list of route rules for opaque TCP traffic.
   *
   * @schema VirtualServiceV1Beta1Spec#tcp
   */
  readonly tcp?: VirtualServiceV1Beta1SpecTcp[];

  /**
   * An ordered list of route rule for non-terminated TLS & HTTPS traffic.
   *
   * @schema VirtualServiceV1Beta1Spec#tls
   */
  readonly tls?: VirtualServiceV1Beta1SpecTls[];

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1Spec(obj: VirtualServiceV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportTo': obj.exportTo?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'hosts': obj.hosts?.map(y => y),
    'http': obj.http?.map(y => toJson_VirtualServiceV1Beta1SpecHttp(y)),
    'tcp': obj.tcp?.map(y => toJson_VirtualServiceV1Beta1SpecTcp(y)),
    'tls': obj.tls?.map(y => toJson_VirtualServiceV1Beta1SpecTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttp
 */
export interface VirtualServiceV1Beta1SpecHttp {
  /**
   * Cross-Origin Resource Sharing policy (CORS).
   *
   * @schema VirtualServiceV1Beta1SpecHttp#corsPolicy
   */
  readonly corsPolicy?: VirtualServiceV1Beta1SpecHttpCorsPolicy;

  /**
   * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#delegate
   */
  readonly delegate?: VirtualServiceV1Beta1SpecHttpDelegate;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#directResponse
   */
  readonly directResponse?: VirtualServiceV1Beta1SpecHttpDirectResponse;

  /**
   * Fault injection policy to apply on HTTP traffic at the client side.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#fault
   */
  readonly fault?: VirtualServiceV1Beta1SpecHttpFault;

  /**
   * @schema VirtualServiceV1Beta1SpecHttp#headers
   */
  readonly headers?: VirtualServiceV1Beta1SpecHttpHeaders;

  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#match
   */
  readonly match?: VirtualServiceV1Beta1SpecHttpMatch[];

  /**
   * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#mirror
   */
  readonly mirror?: VirtualServiceV1Beta1SpecHttpMirror;

  /**
   * @schema VirtualServiceV1Beta1SpecHttp#mirror_percent
   */
  readonly mirror_percent?: number;

  /**
   * @schema VirtualServiceV1Beta1SpecHttp#mirrorPercent
   */
  readonly mirrorPercent?: number;

  /**
   * Percentage of the traffic to be mirrored by the `mirror` field.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#mirrorPercentage
   */
  readonly mirrorPercentage?: VirtualServiceV1Beta1SpecHttpMirrorPercentage;

  /**
   * Specifies the destinations to mirror HTTP traffic in addition to the original destination.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#mirrors
   */
  readonly mirrors?: VirtualServiceV1Beta1SpecHttpMirrors[];

  /**
   * The name assigned to the route for debugging purposes.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#name
   */
  readonly name?: string;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#redirect
   */
  readonly redirect?: VirtualServiceV1Beta1SpecHttpRedirect;

  /**
   * Retry policy for HTTP requests.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#retries
   */
  readonly retries?: VirtualServiceV1Beta1SpecHttpRetries;

  /**
   * Rewrite HTTP URIs and Authority headers.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#rewrite
   */
  readonly rewrite?: VirtualServiceV1Beta1SpecHttpRewrite;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#route
   */
  readonly route?: VirtualServiceV1Beta1SpecHttpRoute[];

  /**
   * Timeout for HTTP requests, default is disabled.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttp(obj: VirtualServiceV1Beta1SpecHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsPolicy': toJson_VirtualServiceV1Beta1SpecHttpCorsPolicy(obj.corsPolicy),
    'delegate': toJson_VirtualServiceV1Beta1SpecHttpDelegate(obj.delegate),
    'directResponse': toJson_VirtualServiceV1Beta1SpecHttpDirectResponse(obj.directResponse),
    'fault': toJson_VirtualServiceV1Beta1SpecHttpFault(obj.fault),
    'headers': toJson_VirtualServiceV1Beta1SpecHttpHeaders(obj.headers),
    'match': obj.match?.map(y => toJson_VirtualServiceV1Beta1SpecHttpMatch(y)),
    'mirror': toJson_VirtualServiceV1Beta1SpecHttpMirror(obj.mirror),
    'mirror_percent': obj.mirrorPercent,
    'mirrorPercent': obj.mirrorPercent,
    'mirrorPercentage': toJson_VirtualServiceV1Beta1SpecHttpMirrorPercentage(obj.mirrorPercentage),
    'mirrors': obj.mirrors?.map(y => toJson_VirtualServiceV1Beta1SpecHttpMirrors(y)),
    'name': obj.name,
    'redirect': toJson_VirtualServiceV1Beta1SpecHttpRedirect(obj.redirect),
    'retries': toJson_VirtualServiceV1Beta1SpecHttpRetries(obj.retries),
    'rewrite': toJson_VirtualServiceV1Beta1SpecHttpRewrite(obj.rewrite),
    'route': obj.route?.map(y => toJson_VirtualServiceV1Beta1SpecHttpRoute(y)),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTcp
 */
export interface VirtualServiceV1Beta1SpecTcp {
  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceV1Beta1SpecTcp#match
   */
  readonly match?: VirtualServiceV1Beta1SpecTcpMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceV1Beta1SpecTcp#route
   */
  readonly route?: VirtualServiceV1Beta1SpecTcpRoute[];

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecTcp(obj: VirtualServiceV1Beta1SpecTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualServiceV1Beta1SpecTcpMatch(y)),
    'route': obj.route?.map(y => toJson_VirtualServiceV1Beta1SpecTcpRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTls
 */
export interface VirtualServiceV1Beta1SpecTls {
  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceV1Beta1SpecTls#match
   */
  readonly match: VirtualServiceV1Beta1SpecTlsMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceV1Beta1SpecTls#route
   */
  readonly route?: VirtualServiceV1Beta1SpecTlsRoute[];

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecTls(obj: VirtualServiceV1Beta1SpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualServiceV1Beta1SpecTlsMatch(y)),
    'route': obj.route?.map(y => toJson_VirtualServiceV1Beta1SpecTlsRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cross-Origin Resource Sharing policy (CORS).
 *
 * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy
 */
export interface VirtualServiceV1Beta1SpecHttpCorsPolicy {
  /**
   * Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * List of HTTP headers that can be used when requesting the resource.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * List of HTTP methods allowed to access the resource.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#allowOrigin
   */
  readonly allowOrigin?: string[];

  /**
   * String patterns that match allowed origins.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#allowOrigins
   */
  readonly allowOrigins?: VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins[];

  /**
   * A list of HTTP headers that the browsers are allowed to access.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Specifies how long the results of a preflight request can be cached.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#maxAge
   */
  readonly maxAge?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpCorsPolicy(obj: VirtualServiceV1Beta1SpecHttpCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigin': obj.allowOrigin?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => toJson_VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins(y)),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
 *
 * @schema VirtualServiceV1Beta1SpecHttpDelegate
 */
export interface VirtualServiceV1Beta1SpecHttpDelegate {
  /**
   * Name specifies the name of the delegate VirtualService.
   *
   * @schema VirtualServiceV1Beta1SpecHttpDelegate#name
   */
  readonly name?: string;

  /**
   * Namespace specifies the namespace where the delegate VirtualService resides.
   *
   * @schema VirtualServiceV1Beta1SpecHttpDelegate#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpDelegate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpDelegate(obj: VirtualServiceV1Beta1SpecHttpDelegate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 *
 * @schema VirtualServiceV1Beta1SpecHttpDirectResponse
 */
export interface VirtualServiceV1Beta1SpecHttpDirectResponse {
  /**
   * Specifies the content of the response body.
   *
   * @schema VirtualServiceV1Beta1SpecHttpDirectResponse#body
   */
  readonly body?: VirtualServiceV1Beta1SpecHttpDirectResponseBody;

  /**
   * Specifies the HTTP response status to be returned.
   *
   * @schema VirtualServiceV1Beta1SpecHttpDirectResponse#status
   */
  readonly status: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpDirectResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpDirectResponse(obj: VirtualServiceV1Beta1SpecHttpDirectResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': toJson_VirtualServiceV1Beta1SpecHttpDirectResponseBody(obj.body),
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fault injection policy to apply on HTTP traffic at the client side.
 *
 * @schema VirtualServiceV1Beta1SpecHttpFault
 */
export interface VirtualServiceV1Beta1SpecHttpFault {
  /**
   * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFault#abort
   */
  readonly abort?: VirtualServiceV1Beta1SpecHttpFaultAbort;

  /**
   * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFault#delay
   */
  readonly delay?: VirtualServiceV1Beta1SpecHttpFaultDelay;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpFault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpFault(obj: VirtualServiceV1Beta1SpecHttpFault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_VirtualServiceV1Beta1SpecHttpFaultAbort(obj.abort),
    'delay': toJson_VirtualServiceV1Beta1SpecHttpFaultDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpHeaders
 */
export interface VirtualServiceV1Beta1SpecHttpHeaders {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeaders#request
   */
  readonly request?: VirtualServiceV1Beta1SpecHttpHeadersRequest;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeaders#response
   */
  readonly response?: VirtualServiceV1Beta1SpecHttpHeadersResponse;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpHeaders(obj: VirtualServiceV1Beta1SpecHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_VirtualServiceV1Beta1SpecHttpHeadersRequest(obj.request),
    'response': toJson_VirtualServiceV1Beta1SpecHttpHeadersResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpMatch
 */
export interface VirtualServiceV1Beta1SpecHttpMatch {
  /**
   * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#authority
   */
  readonly authority?: VirtualServiceV1Beta1SpecHttpMatchAuthority;

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * The header keys must be lowercase and use hyphen as the separator, e.g.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#headers
   */
  readonly headers?: { [key: string]: VirtualServiceV1Beta1SpecHttpMatchHeaders };

  /**
   * Flag to specify whether the URI matching should be case-insensitive.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#ignoreUriCase
   */
  readonly ignoreUriCase?: boolean;

  /**
   * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#method
   */
  readonly method?: VirtualServiceV1Beta1SpecHttpMatchMethod;

  /**
   * The name assigned to a match.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#name
   */
  readonly name?: string;

  /**
   * Specifies the ports on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#port
   */
  readonly port?: number;

  /**
   * Query parameters for matching.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#queryParams
   */
  readonly queryParams?: { [key: string]: VirtualServiceV1Beta1SpecHttpMatchQueryParams };

  /**
   * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#scheme
   */
  readonly scheme?: VirtualServiceV1Beta1SpecHttpMatchScheme;

  /**
   * One or more labels that constrain the applicability of a rule to source (client) workloads with the given labels.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * The human readable prefix to use when emitting statistics for this route.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#statPrefix
   */
  readonly statPrefix?: string;

  /**
   * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#uri
   */
  readonly uri?: VirtualServiceV1Beta1SpecHttpMatchUri;

  /**
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#withoutHeaders
   */
  readonly withoutHeaders?: { [key: string]: VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders };

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatch(obj: VirtualServiceV1Beta1SpecHttpMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': toJson_VirtualServiceV1Beta1SpecHttpMatchAuthority(obj.authority),
    'gateways': obj.gateways?.map(y => y),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceV1Beta1SpecHttpMatchHeaders(i[1]) }), {})),
    'ignoreUriCase': obj.ignoreUriCase,
    'method': toJson_VirtualServiceV1Beta1SpecHttpMatchMethod(obj.method),
    'name': obj.name,
    'port': obj.port,
    'queryParams': ((obj.queryParams) === undefined) ? undefined : (Object.entries(obj.queryParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceV1Beta1SpecHttpMatchQueryParams(i[1]) }), {})),
    'scheme': toJson_VirtualServiceV1Beta1SpecHttpMatchScheme(obj.scheme),
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
    'statPrefix': obj.statPrefix,
    'uri': toJson_VirtualServiceV1Beta1SpecHttpMatchUri(obj.uri),
    'withoutHeaders': ((obj.withoutHeaders) === undefined) ? undefined : (Object.entries(obj.withoutHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirror
 */
export interface VirtualServiceV1Beta1SpecHttpMirror {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirror#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirror#port
   */
  readonly port?: VirtualServiceV1Beta1SpecHttpMirrorPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirror#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirror' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirror(obj: VirtualServiceV1Beta1SpecHttpMirror | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Beta1SpecHttpMirrorPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of the traffic to be mirrored by the `mirror` field.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirrorPercentage
 */
export interface VirtualServiceV1Beta1SpecHttpMirrorPercentage {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMirrorPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrorPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrorPercentage(obj: VirtualServiceV1Beta1SpecHttpMirrorPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpMirrors
 */
export interface VirtualServiceV1Beta1SpecHttpMirrors {
  /**
   * Destination specifies the target of the mirror operation.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirrors#destination
   */
  readonly destination: VirtualServiceV1Beta1SpecHttpMirrorsDestination;

  /**
   * Percentage of the traffic to be mirrored by the `destination` field.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirrors#percentage
   */
  readonly percentage?: VirtualServiceV1Beta1SpecHttpMirrorsPercentage;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrors(obj: VirtualServiceV1Beta1SpecHttpMirrors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Beta1SpecHttpMirrorsDestination(obj.destination),
    'percentage': toJson_VirtualServiceV1Beta1SpecHttpMirrorsPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRedirect
 */
export interface VirtualServiceV1Beta1SpecHttpRedirect {
  /**
   * On a redirect, overwrite the Authority/Host portion of the URL with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#authority
   */
  readonly authority?: string;

  /**
   * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#derivePort
   */
  readonly derivePort?: VirtualServiceV1Beta1SpecHttpRedirectDerivePort;

  /**
   * On a redirect, overwrite the port portion of the URL with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#port
   */
  readonly port?: number;

  /**
   * On a redirect, Specifies the HTTP status code to use in the redirect response.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#redirectCode
   */
  readonly redirectCode?: number;

  /**
   * On a redirect, overwrite the scheme portion of the URL with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#scheme
   */
  readonly scheme?: string;

  /**
   * On a redirect, overwrite the Path portion of the URL with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRedirect(obj: VirtualServiceV1Beta1SpecHttpRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': obj.authority,
    'derivePort': obj.derivePort,
    'port': obj.port,
    'redirectCode': obj.redirectCode,
    'scheme': obj.scheme,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Retry policy for HTTP requests.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRetries
 */
export interface VirtualServiceV1Beta1SpecHttpRetries {
  /**
   * Number of retries to be allowed for a given request.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRetries#attempts
   */
  readonly attempts?: number;

  /**
   * Timeout per attempt for a given request, including the initial call and any retries.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRetries#perTryTimeout
   */
  readonly perTryTimeout?: string;

  /**
   * Specifies the conditions under which retry takes place.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRetries#retryOn
   */
  readonly retryOn?: string;

  /**
   * Flag to specify whether the retries should retry to other localities.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRetries#retryRemoteLocalities
   */
  readonly retryRemoteLocalities?: boolean;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRetries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRetries(obj: VirtualServiceV1Beta1SpecHttpRetries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attempts': obj.attempts,
    'perTryTimeout': obj.perTryTimeout,
    'retryOn': obj.retryOn,
    'retryRemoteLocalities': obj.retryRemoteLocalities,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rewrite HTTP URIs and Authority headers.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRewrite
 */
export interface VirtualServiceV1Beta1SpecHttpRewrite {
  /**
   * rewrite the Authority/Host header with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRewrite#authority
   */
  readonly authority?: string;

  /**
   * rewrite the path (or the prefix) portion of the URI with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRewrite#uri
   */
  readonly uri?: string;

  /**
   * rewrite the path portion of the URI with the specified regex.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRewrite#uriRegexRewrite
   */
  readonly uriRegexRewrite?: VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRewrite(obj: VirtualServiceV1Beta1SpecHttpRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': obj.authority,
    'uri': obj.uri,
    'uriRegexRewrite': toJson_VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite(obj.uriRegexRewrite),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpRoute
 */
export interface VirtualServiceV1Beta1SpecHttpRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRoute#destination
   */
  readonly destination: VirtualServiceV1Beta1SpecHttpRouteDestination;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRoute#headers
   */
  readonly headers?: VirtualServiceV1Beta1SpecHttpRouteHeaders;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRoute(obj: VirtualServiceV1Beta1SpecHttpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Beta1SpecHttpRouteDestination(obj.destination),
    'headers': toJson_VirtualServiceV1Beta1SpecHttpRouteHeaders(obj.headers),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTcpMatch
 */
export interface VirtualServiceV1Beta1SpecTcpMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceV1Beta1SpecTcpMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceV1Beta1SpecTcpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecTcpMatch#port
   */
  readonly port?: number;

  /**
   * One or more labels that constrain the applicability of a rule to workloads with the given labels.
   *
   * @schema VirtualServiceV1Beta1SpecTcpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceV1Beta1SpecTcpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecTcpMatch#sourceSubnet
   */
  readonly sourceSubnet?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTcpMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecTcpMatch(obj: VirtualServiceV1Beta1SpecTcpMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSubnets': obj.destinationSubnets?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'port': obj.port,
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
    'sourceSubnet': obj.sourceSubnet,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTcpRoute
 */
export interface VirtualServiceV1Beta1SpecTcpRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceV1Beta1SpecTcpRoute#destination
   */
  readonly destination: VirtualServiceV1Beta1SpecTcpRouteDestination;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceV1Beta1SpecTcpRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTcpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecTcpRoute(obj: VirtualServiceV1Beta1SpecTcpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Beta1SpecTcpRouteDestination(obj.destination),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTlsMatch
 */
export interface VirtualServiceV1Beta1SpecTlsMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#port
   */
  readonly port?: number;

  /**
   * SNI (server name indicator) to match on.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#sniHosts
   */
  readonly sniHosts: string[];

  /**
   * One or more labels that constrain the applicability of a rule to workloads with the given labels.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTlsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecTlsMatch(obj: VirtualServiceV1Beta1SpecTlsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSubnets': obj.destinationSubnets?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'port': obj.port,
    'sniHosts': obj.sniHosts?.map(y => y),
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTlsRoute
 */
export interface VirtualServiceV1Beta1SpecTlsRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceV1Beta1SpecTlsRoute#destination
   */
  readonly destination: VirtualServiceV1Beta1SpecTlsRouteDestination;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceV1Beta1SpecTlsRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTlsRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecTlsRoute(obj: VirtualServiceV1Beta1SpecTlsRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Beta1SpecTlsRouteDestination(obj.destination),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins
 */
export interface VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins(obj: VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the content of the response body.
 *
 * @schema VirtualServiceV1Beta1SpecHttpDirectResponseBody
 */
export interface VirtualServiceV1Beta1SpecHttpDirectResponseBody {
  /**
   * response body as base64 encoded bytes.
   *
   * @schema VirtualServiceV1Beta1SpecHttpDirectResponseBody#bytes
   */
  readonly bytes?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpDirectResponseBody#string
   */
  readonly string?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpDirectResponseBody' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpDirectResponseBody(obj: VirtualServiceV1Beta1SpecHttpDirectResponseBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bytes': obj.bytes,
    'string': obj.string,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
 *
 * @schema VirtualServiceV1Beta1SpecHttpFaultAbort
 */
export interface VirtualServiceV1Beta1SpecHttpFaultAbort {
  /**
   * GRPC status code to use to abort the request.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultAbort#grpcStatus
   */
  readonly grpcStatus?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpFaultAbort#http2Error
   */
  readonly http2Error?: string;

  /**
   * HTTP status code to use to abort the Http request.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * Percentage of requests to be aborted with the error code provided.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultAbort#percentage
   */
  readonly percentage?: VirtualServiceV1Beta1SpecHttpFaultAbortPercentage;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpFaultAbort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpFaultAbort(obj: VirtualServiceV1Beta1SpecHttpFaultAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcStatus': obj.grpcStatus,
    'http2Error': obj.http2Error,
    'httpStatus': obj.httpStatus,
    'percentage': toJson_VirtualServiceV1Beta1SpecHttpFaultAbortPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
 *
 * @schema VirtualServiceV1Beta1SpecHttpFaultDelay
 */
export interface VirtualServiceV1Beta1SpecHttpFaultDelay {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpFaultDelay#exponentialDelay
   */
  readonly exponentialDelay?: string;

  /**
   * Add a fixed delay before forwarding the request.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultDelay#fixedDelay
   */
  readonly fixedDelay?: string;

  /**
   * Percentage of requests on which the delay will be injected (0-100).
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultDelay#percent
   */
  readonly percent?: number;

  /**
   * Percentage of requests on which the delay will be injected.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultDelay#percentage
   */
  readonly percentage?: VirtualServiceV1Beta1SpecHttpFaultDelayPercentage;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpFaultDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpFaultDelay(obj: VirtualServiceV1Beta1SpecHttpFaultDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exponentialDelay': obj.exponentialDelay,
    'fixedDelay': obj.fixedDelay,
    'percent': obj.percent,
    'percentage': toJson_VirtualServiceV1Beta1SpecHttpFaultDelayPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpHeadersRequest
 */
export interface VirtualServiceV1Beta1SpecHttpHeadersRequest {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersRequest#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpHeadersRequest(obj: VirtualServiceV1Beta1SpecHttpHeadersRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpHeadersResponse
 */
export interface VirtualServiceV1Beta1SpecHttpHeadersResponse {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersResponse#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpHeadersResponse(obj: VirtualServiceV1Beta1SpecHttpHeadersResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Beta1SpecHttpMatchAuthority
 */
export interface VirtualServiceV1Beta1SpecHttpMatchAuthority {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchAuthority#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchAuthority#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchAuthority#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchAuthority' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchAuthority(obj: VirtualServiceV1Beta1SpecHttpMatchAuthority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpMatchHeaders
 */
export interface VirtualServiceV1Beta1SpecHttpMatchHeaders {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchHeaders#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchHeaders(obj: VirtualServiceV1Beta1SpecHttpMatchHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Beta1SpecHttpMatchMethod
 */
export interface VirtualServiceV1Beta1SpecHttpMatchMethod {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchMethod#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchMethod#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchMethod#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchMethod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchMethod(obj: VirtualServiceV1Beta1SpecHttpMatchMethod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpMatchQueryParams
 */
export interface VirtualServiceV1Beta1SpecHttpMatchQueryParams {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchQueryParams#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchQueryParams#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchQueryParams#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchQueryParams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchQueryParams(obj: VirtualServiceV1Beta1SpecHttpMatchQueryParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Beta1SpecHttpMatchScheme
 */
export interface VirtualServiceV1Beta1SpecHttpMatchScheme {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchScheme#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchScheme#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchScheme#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchScheme' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchScheme(obj: VirtualServiceV1Beta1SpecHttpMatchScheme | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Beta1SpecHttpMatchUri
 */
export interface VirtualServiceV1Beta1SpecHttpMatchUri {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchUri#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchUri#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchUri#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchUri' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchUri(obj: VirtualServiceV1Beta1SpecHttpMatchUri | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders
 */
export interface VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders(obj: VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirrorPort
 */
export interface VirtualServiceV1Beta1SpecHttpMirrorPort {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMirrorPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrorPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrorPort(obj: VirtualServiceV1Beta1SpecHttpMirrorPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Destination specifies the target of the mirror operation.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestination
 */
export interface VirtualServiceV1Beta1SpecHttpMirrorsDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestination#port
   */
  readonly port?: VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrorsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrorsDestination(obj: VirtualServiceV1Beta1SpecHttpMirrorsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of the traffic to be mirrored by the `destination` field.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirrorsPercentage
 */
export interface VirtualServiceV1Beta1SpecHttpMirrorsPercentage {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMirrorsPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrorsPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrorsPercentage(obj: VirtualServiceV1Beta1SpecHttpMirrorsPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRedirectDerivePort
 */
export enum VirtualServiceV1Beta1SpecHttpRedirectDerivePort {
  /** FROM_PROTOCOL_DEFAULT */
  FROM_UNDERSCORE_PROTOCOL_UNDERSCORE_DEFAULT = "FROM_PROTOCOL_DEFAULT",
  /** FROM_REQUEST_PORT */
  FROM_UNDERSCORE_REQUEST_UNDERSCORE_PORT = "FROM_REQUEST_PORT",
}

/**
 * rewrite the path portion of the URI with the specified regex.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite
 */
export interface VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite {
  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite#match
   */
  readonly match?: string;

  /**
   * The string that should replace into matching portions of original URI.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite#rewrite
   */
  readonly rewrite?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite(obj: VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match,
    'rewrite': obj.rewrite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRouteDestination
 */
export interface VirtualServiceV1Beta1SpecHttpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRouteDestination#port
   */
  readonly port?: VirtualServiceV1Beta1SpecHttpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRouteDestination(obj: VirtualServiceV1Beta1SpecHttpRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Beta1SpecHttpRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpRouteHeaders
 */
export interface VirtualServiceV1Beta1SpecHttpRouteHeaders {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeaders#request
   */
  readonly request?: VirtualServiceV1Beta1SpecHttpRouteHeadersRequest;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeaders#response
   */
  readonly response?: VirtualServiceV1Beta1SpecHttpRouteHeadersResponse;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRouteHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRouteHeaders(obj: VirtualServiceV1Beta1SpecHttpRouteHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_VirtualServiceV1Beta1SpecHttpRouteHeadersRequest(obj.request),
    'response': toJson_VirtualServiceV1Beta1SpecHttpRouteHeadersResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceV1Beta1SpecTcpRouteDestination
 */
export interface VirtualServiceV1Beta1SpecTcpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Beta1SpecTcpRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecTcpRouteDestination#port
   */
  readonly port?: VirtualServiceV1Beta1SpecTcpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Beta1SpecTcpRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTcpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecTcpRouteDestination(obj: VirtualServiceV1Beta1SpecTcpRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Beta1SpecTcpRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceV1Beta1SpecTlsRouteDestination
 */
export interface VirtualServiceV1Beta1SpecTlsRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Beta1SpecTlsRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecTlsRouteDestination#port
   */
  readonly port?: VirtualServiceV1Beta1SpecTlsRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Beta1SpecTlsRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTlsRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecTlsRouteDestination(obj: VirtualServiceV1Beta1SpecTlsRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Beta1SpecTlsRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of requests to be aborted with the error code provided.
 *
 * @schema VirtualServiceV1Beta1SpecHttpFaultAbortPercentage
 */
export interface VirtualServiceV1Beta1SpecHttpFaultAbortPercentage {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpFaultAbortPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpFaultAbortPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpFaultAbortPercentage(obj: VirtualServiceV1Beta1SpecHttpFaultAbortPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of requests on which the delay will be injected.
 *
 * @schema VirtualServiceV1Beta1SpecHttpFaultDelayPercentage
 */
export interface VirtualServiceV1Beta1SpecHttpFaultDelayPercentage {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpFaultDelayPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpFaultDelayPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpFaultDelayPercentage(obj: VirtualServiceV1Beta1SpecHttpFaultDelayPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort
 */
export interface VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort(obj: VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRouteDestinationPort
 */
export interface VirtualServiceV1Beta1SpecHttpRouteDestinationPort {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRouteDestinationPort(obj: VirtualServiceV1Beta1SpecHttpRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersRequest
 */
export interface VirtualServiceV1Beta1SpecHttpRouteHeadersRequest {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersRequest#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRouteHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRouteHeadersRequest(obj: VirtualServiceV1Beta1SpecHttpRouteHeadersRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersResponse
 */
export interface VirtualServiceV1Beta1SpecHttpRouteHeadersResponse {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersResponse#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRouteHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRouteHeadersResponse(obj: VirtualServiceV1Beta1SpecHttpRouteHeadersResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Beta1SpecTcpRouteDestinationPort
 */
export interface VirtualServiceV1Beta1SpecTcpRouteDestinationPort {
  /**
   * @schema VirtualServiceV1Beta1SpecTcpRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTcpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecTcpRouteDestinationPort(obj: VirtualServiceV1Beta1SpecTcpRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Beta1SpecTlsRouteDestinationPort
 */
export interface VirtualServiceV1Beta1SpecTlsRouteDestinationPort {
  /**
   * @schema VirtualServiceV1Beta1SpecTlsRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTlsRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceV1Beta1SpecTlsRouteDestinationPort(obj: VirtualServiceV1Beta1SpecTlsRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

