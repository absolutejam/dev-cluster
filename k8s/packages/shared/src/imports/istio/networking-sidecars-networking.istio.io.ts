// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema Sidecar
 */
export class Sidecar extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Sidecar"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'Sidecar',
  }

  /**
   * Renders a Kubernetes manifest for "Sidecar".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SidecarProps = {}): any {
    return {
      ...Sidecar.GVK,
      ...toJson_SidecarProps(props),
    };
  }

  /**
   * Defines a "Sidecar" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SidecarProps = {}) {
    super(scope, id, {
      ...Sidecar.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Sidecar.GVK,
      ...toJson_SidecarProps(resolved),
    };
  }
}

/**
 * @schema Sidecar
 */
export interface SidecarProps {
  /**
   * @schema Sidecar#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
   *
   * @schema Sidecar#spec
   */
  readonly spec?: SidecarSpec;

}

/**
 * Converts an object of type 'SidecarProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarProps(obj: SidecarProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SidecarSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
 *
 * @schema SidecarSpec
 */
export interface SidecarSpec {
  /**
   * Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh.
   *
   * @schema SidecarSpec#egress
   */
  readonly egress?: SidecarSpecEgress[];

  /**
   * Settings controlling the volume of connections Envoy will accept from the network.
   *
   * @schema SidecarSpec#inboundConnectionPool
   */
  readonly inboundConnectionPool?: SidecarSpecInboundConnectionPool;

  /**
   * Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance.
   *
   * @schema SidecarSpec#ingress
   */
  readonly ingress?: SidecarSpecIngress[];

  /**
   * Configuration for the outbound traffic policy.
   *
   * @schema SidecarSpec#outboundTrafficPolicy
   */
  readonly outboundTrafficPolicy?: SidecarSpecOutboundTrafficPolicy;

  /**
   * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
   *
   * @schema SidecarSpec#workloadSelector
   */
  readonly workloadSelector?: SidecarSpecWorkloadSelector;

}

/**
 * Converts an object of type 'SidecarSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpec(obj: SidecarSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egress': obj.egress?.map(y => toJson_SidecarSpecEgress(y)),
    'inboundConnectionPool': toJson_SidecarSpecInboundConnectionPool(obj.inboundConnectionPool),
    'ingress': obj.ingress?.map(y => toJson_SidecarSpecIngress(y)),
    'outboundTrafficPolicy': toJson_SidecarSpecOutboundTrafficPolicy(obj.outboundTrafficPolicy),
    'workloadSelector': toJson_SidecarSpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarSpecEgress
 */
export interface SidecarSpecEgress {
  /**
   * The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.
   *
   * @schema SidecarSpecEgress#bind
   */
  readonly bind?: string;

  /**
   * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
   *
   * @schema SidecarSpecEgress#captureMode
   */
  readonly captureMode?: SidecarSpecEgressCaptureMode;

  /**
   * One or more service hosts exposed by the listener in `namespace/dnsName` format.
   *
   * @schema SidecarSpecEgress#hosts
   */
  readonly hosts: string[];

  /**
   * The port associated with the listener.
   *
   * @schema SidecarSpecEgress#port
   */
  readonly port?: SidecarSpecEgressPort;

}

/**
 * Converts an object of type 'SidecarSpecEgress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecEgress(obj: SidecarSpecEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'captureMode': obj.captureMode,
    'hosts': obj.hosts?.map(y => y),
    'port': toJson_SidecarSpecEgressPort(obj.port),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the volume of connections Envoy will accept from the network.
 *
 * @schema SidecarSpecInboundConnectionPool
 */
export interface SidecarSpecInboundConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema SidecarSpecInboundConnectionPool#http
   */
  readonly http?: SidecarSpecInboundConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema SidecarSpecInboundConnectionPool#tcp
   */
  readonly tcp?: SidecarSpecInboundConnectionPoolTcp;

}

/**
 * Converts an object of type 'SidecarSpecInboundConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecInboundConnectionPool(obj: SidecarSpecInboundConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SidecarSpecInboundConnectionPoolHttp(obj.http),
    'tcp': toJson_SidecarSpecInboundConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarSpecIngress
 */
export interface SidecarSpecIngress {
  /**
   * The IP(IPv4 or IPv6) to which the listener should be bound.
   *
   * @schema SidecarSpecIngress#bind
   */
  readonly bind?: string;

  /**
   * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
   *
   * @schema SidecarSpecIngress#captureMode
   */
  readonly captureMode?: SidecarSpecIngressCaptureMode;

  /**
   * Settings controlling the volume of connections Envoy will accept from the network.
   *
   * @schema SidecarSpecIngress#connectionPool
   */
  readonly connectionPool?: SidecarSpecIngressConnectionPool;

  /**
   * The IP endpoint or Unix domain socket to which traffic should be forwarded to.
   *
   * @schema SidecarSpecIngress#defaultEndpoint
   */
  readonly defaultEndpoint?: string;

  /**
   * The port associated with the listener.
   *
   * @schema SidecarSpecIngress#port
   */
  readonly port: SidecarSpecIngressPort;

  /**
   * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
   *
   * @schema SidecarSpecIngress#tls
   */
  readonly tls?: SidecarSpecIngressTls;

}

/**
 * Converts an object of type 'SidecarSpecIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecIngress(obj: SidecarSpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'captureMode': obj.captureMode,
    'connectionPool': toJson_SidecarSpecIngressConnectionPool(obj.connectionPool),
    'defaultEndpoint': obj.defaultEndpoint,
    'port': toJson_SidecarSpecIngressPort(obj.port),
    'tls': toJson_SidecarSpecIngressTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration for the outbound traffic policy.
 *
 * @schema SidecarSpecOutboundTrafficPolicy
 */
export interface SidecarSpecOutboundTrafficPolicy {
  /**
   * @schema SidecarSpecOutboundTrafficPolicy#egressProxy
   */
  readonly egressProxy?: SidecarSpecOutboundTrafficPolicyEgressProxy;

  /**
   * @schema SidecarSpecOutboundTrafficPolicy#mode
   */
  readonly mode?: SidecarSpecOutboundTrafficPolicyMode;

}

/**
 * Converts an object of type 'SidecarSpecOutboundTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecOutboundTrafficPolicy(obj: SidecarSpecOutboundTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressProxy': toJson_SidecarSpecOutboundTrafficPolicyEgressProxy(obj.egressProxy),
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
 *
 * @schema SidecarSpecWorkloadSelector
 */
export interface SidecarSpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
   *
   * @schema SidecarSpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SidecarSpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecWorkloadSelector(obj: SidecarSpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
 *
 * @schema SidecarSpecEgressCaptureMode
 */
export enum SidecarSpecEgressCaptureMode {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** IPTABLES */
  IPTABLES = "IPTABLES",
  /** NONE */
  NONE = "NONE",
}

/**
 * The port associated with the listener.
 *
 * @schema SidecarSpecEgressPort
 */
export interface SidecarSpecEgressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarSpecEgressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarSpecEgressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarSpecEgressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarSpecEgressPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'SidecarSpecEgressPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecEgressPort(obj: SidecarSpecEgressPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema SidecarSpecInboundConnectionPoolHttp
 */
export interface SidecarSpecInboundConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: SidecarSpecInboundConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'SidecarSpecInboundConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecInboundConnectionPoolHttp(obj: SidecarSpecInboundConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema SidecarSpecInboundConnectionPoolTcp
 */
export interface SidecarSpecInboundConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema SidecarSpecInboundConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema SidecarSpecInboundConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema SidecarSpecInboundConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema SidecarSpecInboundConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: SidecarSpecInboundConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'SidecarSpecInboundConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecInboundConnectionPoolTcp(obj: SidecarSpecInboundConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_SidecarSpecInboundConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
 *
 * @schema SidecarSpecIngressCaptureMode
 */
export enum SidecarSpecIngressCaptureMode {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** IPTABLES */
  IPTABLES = "IPTABLES",
  /** NONE */
  NONE = "NONE",
}

/**
 * Settings controlling the volume of connections Envoy will accept from the network.
 *
 * @schema SidecarSpecIngressConnectionPool
 */
export interface SidecarSpecIngressConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema SidecarSpecIngressConnectionPool#http
   */
  readonly http?: SidecarSpecIngressConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema SidecarSpecIngressConnectionPool#tcp
   */
  readonly tcp?: SidecarSpecIngressConnectionPoolTcp;

}

/**
 * Converts an object of type 'SidecarSpecIngressConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecIngressConnectionPool(obj: SidecarSpecIngressConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SidecarSpecIngressConnectionPoolHttp(obj.http),
    'tcp': toJson_SidecarSpecIngressConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The port associated with the listener.
 *
 * @schema SidecarSpecIngressPort
 */
export interface SidecarSpecIngressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarSpecIngressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarSpecIngressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarSpecIngressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarSpecIngressPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'SidecarSpecIngressPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecIngressPort(obj: SidecarSpecIngressPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
 *
 * @schema SidecarSpecIngressTls
 */
export interface SidecarSpecIngressTls {
  /**
   * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
   *
   * @schema SidecarSpecIngressTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * Optional: If specified, only support the specified cipher list.
   *
   * @schema SidecarSpecIngressTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
   *
   * @schema SidecarSpecIngressTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
   *
   * @schema SidecarSpecIngressTls#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * Optional: Maximum TLS protocol version.
   *
   * @schema SidecarSpecIngressTls#maxProtocolVersion
   */
  readonly maxProtocolVersion?: SidecarSpecIngressTlsMaxProtocolVersion;

  /**
   * Optional: Minimum TLS protocol version.
   *
   * @schema SidecarSpecIngressTls#minProtocolVersion
   */
  readonly minProtocolVersion?: SidecarSpecIngressTlsMinProtocolVersion;

  /**
   * Optional: Indicates whether connections to this port should be secured using TLS.
   *
   * @schema SidecarSpecIngressTls#mode
   */
  readonly mode?: SidecarSpecIngressTlsMode;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarSpecIngressTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarSpecIngressTls#serverCertificate
   */
  readonly serverCertificate?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate presented by the client.
   *
   * @schema SidecarSpecIngressTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
   *
   * @schema SidecarSpecIngressTls#verifyCertificateHash
   */
  readonly verifyCertificateHash?: string[];

  /**
   * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
   *
   * @schema SidecarSpecIngressTls#verifyCertificateSpki
   */
  readonly verifyCertificateSpki?: string[];

}

/**
 * Converts an object of type 'SidecarSpecIngressTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecIngressTls(obj: SidecarSpecIngressTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'credentialName': obj.credentialName,
    'httpsRedirect': obj.httpsRedirect,
    'maxProtocolVersion': obj.maxProtocolVersion,
    'minProtocolVersion': obj.minProtocolVersion,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
    'verifyCertificateHash': obj.verifyCertificateHash?.map(y => y),
    'verifyCertificateSpki': obj.verifyCertificateSpki?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarSpecOutboundTrafficPolicyEgressProxy
 */
export interface SidecarSpecOutboundTrafficPolicyEgressProxy {
  /**
   * The name of a service from the service registry.
   *
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxy#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxy#port
   */
  readonly port?: SidecarSpecOutboundTrafficPolicyEgressProxyPort;

  /**
   * The name of a subset within the service.
   *
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxy#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'SidecarSpecOutboundTrafficPolicyEgressProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecOutboundTrafficPolicyEgressProxy(obj: SidecarSpecOutboundTrafficPolicyEgressProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_SidecarSpecOutboundTrafficPolicyEgressProxyPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarSpecOutboundTrafficPolicyMode
 */
export enum SidecarSpecOutboundTrafficPolicyMode {
  /** REGISTRY_ONLY */
  REGISTRY_UNDERSCORE_ONLY = "REGISTRY_ONLY",
  /** ALLOW_ANY */
  ALLOW_UNDERSCORE_ANY = "ALLOW_ANY",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema SidecarSpecInboundConnectionPoolHttpH2UpgradePolicy
 */
export enum SidecarSpecInboundConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema SidecarSpecInboundConnectionPoolTcpTcpKeepalive
 */
export interface SidecarSpecInboundConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema SidecarSpecInboundConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema SidecarSpecInboundConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema SidecarSpecInboundConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'SidecarSpecInboundConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecInboundConnectionPoolTcpTcpKeepalive(obj: SidecarSpecInboundConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema SidecarSpecIngressConnectionPoolHttp
 */
export interface SidecarSpecIngressConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: SidecarSpecIngressConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'SidecarSpecIngressConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecIngressConnectionPoolHttp(obj: SidecarSpecIngressConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema SidecarSpecIngressConnectionPoolTcp
 */
export interface SidecarSpecIngressConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema SidecarSpecIngressConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema SidecarSpecIngressConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema SidecarSpecIngressConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema SidecarSpecIngressConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: SidecarSpecIngressConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'SidecarSpecIngressConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecIngressConnectionPoolTcp(obj: SidecarSpecIngressConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_SidecarSpecIngressConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: Maximum TLS protocol version.
 *
 * @schema SidecarSpecIngressTlsMaxProtocolVersion
 */
export enum SidecarSpecIngressTlsMaxProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Minimum TLS protocol version.
 *
 * @schema SidecarSpecIngressTlsMinProtocolVersion
 */
export enum SidecarSpecIngressTlsMinProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Indicates whether connections to this port should be secured using TLS.
 *
 * @schema SidecarSpecIngressTlsMode
 */
export enum SidecarSpecIngressTlsMode {
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** AUTO_PASSTHROUGH */
  AUTO_UNDERSCORE_PASSTHROUGH = "AUTO_PASSTHROUGH",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
  /** OPTIONAL_MUTUAL */
  OPTIONAL_UNDERSCORE_MUTUAL = "OPTIONAL_MUTUAL",
}

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema SidecarSpecOutboundTrafficPolicyEgressProxyPort
 */
export interface SidecarSpecOutboundTrafficPolicyEgressProxyPort {
  /**
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxyPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'SidecarSpecOutboundTrafficPolicyEgressProxyPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecOutboundTrafficPolicyEgressProxyPort(obj: SidecarSpecOutboundTrafficPolicyEgressProxyPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema SidecarSpecIngressConnectionPoolHttpH2UpgradePolicy
 */
export enum SidecarSpecIngressConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema SidecarSpecIngressConnectionPoolTcpTcpKeepalive
 */
export interface SidecarSpecIngressConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema SidecarSpecIngressConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema SidecarSpecIngressConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema SidecarSpecIngressConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'SidecarSpecIngressConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecIngressConnectionPoolTcpTcpKeepalive(obj: SidecarSpecIngressConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema SidecarV1Beta1
 */
export class SidecarV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SidecarV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'Sidecar',
  }

  /**
   * Renders a Kubernetes manifest for "SidecarV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SidecarV1Beta1Props = {}): any {
    return {
      ...SidecarV1Beta1.GVK,
      ...toJson_SidecarV1Beta1Props(props),
    };
  }

  /**
   * Defines a "SidecarV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SidecarV1Beta1Props = {}) {
    super(scope, id, {
      ...SidecarV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SidecarV1Beta1.GVK,
      ...toJson_SidecarV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema SidecarV1Beta1
 */
export interface SidecarV1Beta1Props {
  /**
   * @schema SidecarV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
   *
   * @schema SidecarV1Beta1#spec
   */
  readonly spec?: SidecarV1Beta1Spec;

}

/**
 * Converts an object of type 'SidecarV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1Props(obj: SidecarV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SidecarV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
 *
 * @schema SidecarV1Beta1Spec
 */
export interface SidecarV1Beta1Spec {
  /**
   * Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh.
   *
   * @schema SidecarV1Beta1Spec#egress
   */
  readonly egress?: SidecarV1Beta1SpecEgress[];

  /**
   * Settings controlling the volume of connections Envoy will accept from the network.
   *
   * @schema SidecarV1Beta1Spec#inboundConnectionPool
   */
  readonly inboundConnectionPool?: SidecarV1Beta1SpecInboundConnectionPool;

  /**
   * Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance.
   *
   * @schema SidecarV1Beta1Spec#ingress
   */
  readonly ingress?: SidecarV1Beta1SpecIngress[];

  /**
   * Configuration for the outbound traffic policy.
   *
   * @schema SidecarV1Beta1Spec#outboundTrafficPolicy
   */
  readonly outboundTrafficPolicy?: SidecarV1Beta1SpecOutboundTrafficPolicy;

  /**
   * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
   *
   * @schema SidecarV1Beta1Spec#workloadSelector
   */
  readonly workloadSelector?: SidecarV1Beta1SpecWorkloadSelector;

}

/**
 * Converts an object of type 'SidecarV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1Spec(obj: SidecarV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egress': obj.egress?.map(y => toJson_SidecarV1Beta1SpecEgress(y)),
    'inboundConnectionPool': toJson_SidecarV1Beta1SpecInboundConnectionPool(obj.inboundConnectionPool),
    'ingress': obj.ingress?.map(y => toJson_SidecarV1Beta1SpecIngress(y)),
    'outboundTrafficPolicy': toJson_SidecarV1Beta1SpecOutboundTrafficPolicy(obj.outboundTrafficPolicy),
    'workloadSelector': toJson_SidecarV1Beta1SpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarV1Beta1SpecEgress
 */
export interface SidecarV1Beta1SpecEgress {
  /**
   * The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.
   *
   * @schema SidecarV1Beta1SpecEgress#bind
   */
  readonly bind?: string;

  /**
   * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
   *
   * @schema SidecarV1Beta1SpecEgress#captureMode
   */
  readonly captureMode?: SidecarV1Beta1SpecEgressCaptureMode;

  /**
   * One or more service hosts exposed by the listener in `namespace/dnsName` format.
   *
   * @schema SidecarV1Beta1SpecEgress#hosts
   */
  readonly hosts: string[];

  /**
   * The port associated with the listener.
   *
   * @schema SidecarV1Beta1SpecEgress#port
   */
  readonly port?: SidecarV1Beta1SpecEgressPort;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecEgress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecEgress(obj: SidecarV1Beta1SpecEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'captureMode': obj.captureMode,
    'hosts': obj.hosts?.map(y => y),
    'port': toJson_SidecarV1Beta1SpecEgressPort(obj.port),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the volume of connections Envoy will accept from the network.
 *
 * @schema SidecarV1Beta1SpecInboundConnectionPool
 */
export interface SidecarV1Beta1SpecInboundConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPool#http
   */
  readonly http?: SidecarV1Beta1SpecInboundConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPool#tcp
   */
  readonly tcp?: SidecarV1Beta1SpecInboundConnectionPoolTcp;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecInboundConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecInboundConnectionPool(obj: SidecarV1Beta1SpecInboundConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SidecarV1Beta1SpecInboundConnectionPoolHttp(obj.http),
    'tcp': toJson_SidecarV1Beta1SpecInboundConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarV1Beta1SpecIngress
 */
export interface SidecarV1Beta1SpecIngress {
  /**
   * The IP(IPv4 or IPv6) to which the listener should be bound.
   *
   * @schema SidecarV1Beta1SpecIngress#bind
   */
  readonly bind?: string;

  /**
   * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
   *
   * @schema SidecarV1Beta1SpecIngress#captureMode
   */
  readonly captureMode?: SidecarV1Beta1SpecIngressCaptureMode;

  /**
   * Settings controlling the volume of connections Envoy will accept from the network.
   *
   * @schema SidecarV1Beta1SpecIngress#connectionPool
   */
  readonly connectionPool?: SidecarV1Beta1SpecIngressConnectionPool;

  /**
   * The IP endpoint or Unix domain socket to which traffic should be forwarded to.
   *
   * @schema SidecarV1Beta1SpecIngress#defaultEndpoint
   */
  readonly defaultEndpoint?: string;

  /**
   * The port associated with the listener.
   *
   * @schema SidecarV1Beta1SpecIngress#port
   */
  readonly port: SidecarV1Beta1SpecIngressPort;

  /**
   * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
   *
   * @schema SidecarV1Beta1SpecIngress#tls
   */
  readonly tls?: SidecarV1Beta1SpecIngressTls;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecIngress(obj: SidecarV1Beta1SpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'captureMode': obj.captureMode,
    'connectionPool': toJson_SidecarV1Beta1SpecIngressConnectionPool(obj.connectionPool),
    'defaultEndpoint': obj.defaultEndpoint,
    'port': toJson_SidecarV1Beta1SpecIngressPort(obj.port),
    'tls': toJson_SidecarV1Beta1SpecIngressTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration for the outbound traffic policy.
 *
 * @schema SidecarV1Beta1SpecOutboundTrafficPolicy
 */
export interface SidecarV1Beta1SpecOutboundTrafficPolicy {
  /**
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicy#egressProxy
   */
  readonly egressProxy?: SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy;

  /**
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicy#mode
   */
  readonly mode?: SidecarV1Beta1SpecOutboundTrafficPolicyMode;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecOutboundTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecOutboundTrafficPolicy(obj: SidecarV1Beta1SpecOutboundTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressProxy': toJson_SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy(obj.egressProxy),
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
 *
 * @schema SidecarV1Beta1SpecWorkloadSelector
 */
export interface SidecarV1Beta1SpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
   *
   * @schema SidecarV1Beta1SpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecWorkloadSelector(obj: SidecarV1Beta1SpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
 *
 * @schema SidecarV1Beta1SpecEgressCaptureMode
 */
export enum SidecarV1Beta1SpecEgressCaptureMode {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** IPTABLES */
  IPTABLES = "IPTABLES",
  /** NONE */
  NONE = "NONE",
}

/**
 * The port associated with the listener.
 *
 * @schema SidecarV1Beta1SpecEgressPort
 */
export interface SidecarV1Beta1SpecEgressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarV1Beta1SpecEgressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarV1Beta1SpecEgressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarV1Beta1SpecEgressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarV1Beta1SpecEgressPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecEgressPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecEgressPort(obj: SidecarV1Beta1SpecEgressPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp
 */
export interface SidecarV1Beta1SpecInboundConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: SidecarV1Beta1SpecInboundConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecInboundConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecInboundConnectionPoolHttp(obj: SidecarV1Beta1SpecInboundConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema SidecarV1Beta1SpecInboundConnectionPoolTcp
 */
export interface SidecarV1Beta1SpecInboundConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecInboundConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecInboundConnectionPoolTcp(obj: SidecarV1Beta1SpecInboundConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
 *
 * @schema SidecarV1Beta1SpecIngressCaptureMode
 */
export enum SidecarV1Beta1SpecIngressCaptureMode {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** IPTABLES */
  IPTABLES = "IPTABLES",
  /** NONE */
  NONE = "NONE",
}

/**
 * Settings controlling the volume of connections Envoy will accept from the network.
 *
 * @schema SidecarV1Beta1SpecIngressConnectionPool
 */
export interface SidecarV1Beta1SpecIngressConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPool#http
   */
  readonly http?: SidecarV1Beta1SpecIngressConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPool#tcp
   */
  readonly tcp?: SidecarV1Beta1SpecIngressConnectionPoolTcp;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecIngressConnectionPool(obj: SidecarV1Beta1SpecIngressConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SidecarV1Beta1SpecIngressConnectionPoolHttp(obj.http),
    'tcp': toJson_SidecarV1Beta1SpecIngressConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The port associated with the listener.
 *
 * @schema SidecarV1Beta1SpecIngressPort
 */
export interface SidecarV1Beta1SpecIngressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarV1Beta1SpecIngressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarV1Beta1SpecIngressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarV1Beta1SpecIngressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarV1Beta1SpecIngressPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecIngressPort(obj: SidecarV1Beta1SpecIngressPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
 *
 * @schema SidecarV1Beta1SpecIngressTls
 */
export interface SidecarV1Beta1SpecIngressTls {
  /**
   * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
   *
   * @schema SidecarV1Beta1SpecIngressTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * Optional: If specified, only support the specified cipher list.
   *
   * @schema SidecarV1Beta1SpecIngressTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
   *
   * @schema SidecarV1Beta1SpecIngressTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
   *
   * @schema SidecarV1Beta1SpecIngressTls#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * Optional: Maximum TLS protocol version.
   *
   * @schema SidecarV1Beta1SpecIngressTls#maxProtocolVersion
   */
  readonly maxProtocolVersion?: SidecarV1Beta1SpecIngressTlsMaxProtocolVersion;

  /**
   * Optional: Minimum TLS protocol version.
   *
   * @schema SidecarV1Beta1SpecIngressTls#minProtocolVersion
   */
  readonly minProtocolVersion?: SidecarV1Beta1SpecIngressTlsMinProtocolVersion;

  /**
   * Optional: Indicates whether connections to this port should be secured using TLS.
   *
   * @schema SidecarV1Beta1SpecIngressTls#mode
   */
  readonly mode?: SidecarV1Beta1SpecIngressTlsMode;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarV1Beta1SpecIngressTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarV1Beta1SpecIngressTls#serverCertificate
   */
  readonly serverCertificate?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate presented by the client.
   *
   * @schema SidecarV1Beta1SpecIngressTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
   *
   * @schema SidecarV1Beta1SpecIngressTls#verifyCertificateHash
   */
  readonly verifyCertificateHash?: string[];

  /**
   * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
   *
   * @schema SidecarV1Beta1SpecIngressTls#verifyCertificateSpki
   */
  readonly verifyCertificateSpki?: string[];

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecIngressTls(obj: SidecarV1Beta1SpecIngressTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'credentialName': obj.credentialName,
    'httpsRedirect': obj.httpsRedirect,
    'maxProtocolVersion': obj.maxProtocolVersion,
    'minProtocolVersion': obj.minProtocolVersion,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
    'verifyCertificateHash': obj.verifyCertificateHash?.map(y => y),
    'verifyCertificateSpki': obj.verifyCertificateSpki?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy
 */
export interface SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy {
  /**
   * The name of a service from the service registry.
   *
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy#port
   */
  readonly port?: SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort;

  /**
   * The name of a subset within the service.
   *
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy(obj: SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarV1Beta1SpecOutboundTrafficPolicyMode
 */
export enum SidecarV1Beta1SpecOutboundTrafficPolicyMode {
  /** REGISTRY_ONLY */
  REGISTRY_UNDERSCORE_ONLY = "REGISTRY_ONLY",
  /** ALLOW_ANY */
  ALLOW_UNDERSCORE_ANY = "ALLOW_ANY",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema SidecarV1Beta1SpecInboundConnectionPoolHttpH2UpgradePolicy
 */
export enum SidecarV1Beta1SpecInboundConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive
 */
export interface SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive(obj: SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp
 */
export interface SidecarV1Beta1SpecIngressConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: SidecarV1Beta1SpecIngressConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecIngressConnectionPoolHttp(obj: SidecarV1Beta1SpecIngressConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema SidecarV1Beta1SpecIngressConnectionPoolTcp
 */
export interface SidecarV1Beta1SpecIngressConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecIngressConnectionPoolTcp(obj: SidecarV1Beta1SpecIngressConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: Maximum TLS protocol version.
 *
 * @schema SidecarV1Beta1SpecIngressTlsMaxProtocolVersion
 */
export enum SidecarV1Beta1SpecIngressTlsMaxProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Minimum TLS protocol version.
 *
 * @schema SidecarV1Beta1SpecIngressTlsMinProtocolVersion
 */
export enum SidecarV1Beta1SpecIngressTlsMinProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Indicates whether connections to this port should be secured using TLS.
 *
 * @schema SidecarV1Beta1SpecIngressTlsMode
 */
export enum SidecarV1Beta1SpecIngressTlsMode {
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** AUTO_PASSTHROUGH */
  AUTO_UNDERSCORE_PASSTHROUGH = "AUTO_PASSTHROUGH",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
  /** OPTIONAL_MUTUAL */
  OPTIONAL_UNDERSCORE_MUTUAL = "OPTIONAL_MUTUAL",
}

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort
 */
export interface SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort {
  /**
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort(obj: SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema SidecarV1Beta1SpecIngressConnectionPoolHttpH2UpgradePolicy
 */
export enum SidecarV1Beta1SpecIngressConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive
 */
export interface SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive(obj: SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

