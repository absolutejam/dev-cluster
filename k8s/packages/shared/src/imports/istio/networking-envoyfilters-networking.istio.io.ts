// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema EnvoyFilter
 */
export class EnvoyFilter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EnvoyFilter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'EnvoyFilter',
  }

  /**
   * Renders a Kubernetes manifest for "EnvoyFilter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvoyFilterProps = {}): any {
    return {
      ...EnvoyFilter.GVK,
      ...toJson_EnvoyFilterProps(props),
    };
  }

  /**
   * Defines a "EnvoyFilter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvoyFilterProps = {}) {
    super(scope, id, {
      ...EnvoyFilter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EnvoyFilter.GVK,
      ...toJson_EnvoyFilterProps(resolved),
    };
  }
}

/**
 * @schema EnvoyFilter
 */
export interface EnvoyFilterProps {
  /**
   * @schema EnvoyFilter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
   *
   * @schema EnvoyFilter#spec
   */
  readonly spec?: EnvoyFilterSpec;

}

/**
 * Converts an object of type 'EnvoyFilterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterProps(obj: EnvoyFilterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvoyFilterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
 *
 * @schema EnvoyFilterSpec
 */
export interface EnvoyFilterSpec {
  /**
   * One or more patches with match conditions.
   *
   * @schema EnvoyFilterSpec#configPatches
   */
  readonly configPatches?: EnvoyFilterSpecConfigPatches[];

  /**
   * Priority defines the order in which patch sets are applied within a context.
   *
   * @schema EnvoyFilterSpec#priority
   */
  readonly priority?: number;

  /**
   * Criteria used to select the specific set of pods/VMs on which this patch configuration should be applied.
   *
   * @schema EnvoyFilterSpec#workloadSelector
   */
  readonly workloadSelector?: EnvoyFilterSpecWorkloadSelector;

}

/**
 * Converts an object of type 'EnvoyFilterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpec(obj: EnvoyFilterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configPatches': obj.configPatches?.map(y => toJson_EnvoyFilterSpecConfigPatches(y)),
    'priority': obj.priority,
    'workloadSelector': toJson_EnvoyFilterSpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvoyFilterSpecConfigPatches
 */
export interface EnvoyFilterSpecConfigPatches {
  /**
   * Specifies where in the Envoy configuration, the patch should be applied.
   *
   * @schema EnvoyFilterSpecConfigPatches#applyTo
   */
  readonly applyTo?: EnvoyFilterSpecConfigPatchesApplyTo;

  /**
   * Match on listener/route configuration/cluster.
   *
   * @schema EnvoyFilterSpecConfigPatches#match
   */
  readonly match?: EnvoyFilterSpecConfigPatchesMatch;

  /**
   * The patch to apply along with the operation.
   *
   * @schema EnvoyFilterSpecConfigPatches#patch
   */
  readonly patch?: EnvoyFilterSpecConfigPatchesPatch;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatches(obj: EnvoyFilterSpecConfigPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyTo': obj.applyTo,
    'match': toJson_EnvoyFilterSpecConfigPatchesMatch(obj.match),
    'patch': toJson_EnvoyFilterSpecConfigPatchesPatch(obj.patch),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this patch configuration should be applied.
 *
 * @schema EnvoyFilterSpecWorkloadSelector
 */
export interface EnvoyFilterSpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
   *
   * @schema EnvoyFilterSpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'EnvoyFilterSpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecWorkloadSelector(obj: EnvoyFilterSpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies where in the Envoy configuration, the patch should be applied.
 *
 * @schema EnvoyFilterSpecConfigPatchesApplyTo
 */
export enum EnvoyFilterSpecConfigPatchesApplyTo {
  /** INVALID */
  INVALID = "INVALID",
  /** LISTENER */
  LISTENER = "LISTENER",
  /** FILTER_CHAIN */
  FILTER_UNDERSCORE_CHAIN = "FILTER_CHAIN",
  /** NETWORK_FILTER */
  NETWORK_UNDERSCORE_FILTER = "NETWORK_FILTER",
  /** HTTP_FILTER */
  HTTP_UNDERSCORE_FILTER = "HTTP_FILTER",
  /** ROUTE_CONFIGURATION */
  ROUTE_UNDERSCORE_CONFIGURATION = "ROUTE_CONFIGURATION",
  /** VIRTUAL_HOST */
  VIRTUAL_UNDERSCORE_HOST = "VIRTUAL_HOST",
  /** HTTP_ROUTE */
  HTTP_UNDERSCORE_ROUTE = "HTTP_ROUTE",
  /** CLUSTER */
  CLUSTER = "CLUSTER",
  /** EXTENSION_CONFIG */
  EXTENSION_UNDERSCORE_CONFIG = "EXTENSION_CONFIG",
  /** BOOTSTRAP */
  BOOTSTRAP = "BOOTSTRAP",
  /** LISTENER_FILTER */
  LISTENER_UNDERSCORE_FILTER = "LISTENER_FILTER",
}

/**
 * Match on listener/route configuration/cluster.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatch
 */
export interface EnvoyFilterSpecConfigPatchesMatch {
  /**
   * Match on envoy cluster attributes.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#cluster
   */
  readonly cluster?: EnvoyFilterSpecConfigPatchesMatchCluster;

  /**
   * The specific config generation context to match on.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#context
   */
  readonly context?: EnvoyFilterSpecConfigPatchesMatchContext;

  /**
   * Match on envoy listener attributes.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#listener
   */
  readonly listener?: EnvoyFilterSpecConfigPatchesMatchListener;

  /**
   * Match on properties associated with a proxy.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#proxy
   */
  readonly proxy?: EnvoyFilterSpecConfigPatchesMatchProxy;

  /**
   * Match on envoy HTTP route configuration attributes.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#routeConfiguration
   */
  readonly routeConfiguration?: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatch(obj: EnvoyFilterSpecConfigPatchesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cluster': toJson_EnvoyFilterSpecConfigPatchesMatchCluster(obj.cluster),
    'context': obj.context,
    'listener': toJson_EnvoyFilterSpecConfigPatchesMatchListener(obj.listener),
    'proxy': toJson_EnvoyFilterSpecConfigPatchesMatchProxy(obj.proxy),
    'routeConfiguration': toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfiguration(obj.routeConfiguration),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The patch to apply along with the operation.
 *
 * @schema EnvoyFilterSpecConfigPatchesPatch
 */
export interface EnvoyFilterSpecConfigPatchesPatch {
  /**
   * Determines the filter insertion order.
   *
   * @schema EnvoyFilterSpecConfigPatchesPatch#filterClass
   */
  readonly filterClass?: EnvoyFilterSpecConfigPatchesPatchFilterClass;

  /**
   * Determines how the patch should be applied.
   *
   * @schema EnvoyFilterSpecConfigPatchesPatch#operation
   */
  readonly operation?: EnvoyFilterSpecConfigPatchesPatchOperation;

  /**
   * The JSON config of the object being patched.
   *
   * @schema EnvoyFilterSpecConfigPatchesPatch#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesPatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesPatch(obj: EnvoyFilterSpecConfigPatchesPatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterClass': obj.filterClass,
    'operation': obj.operation,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match on envoy cluster attributes.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchCluster
 */
export interface EnvoyFilterSpecConfigPatchesMatchCluster {
  /**
   * The exact name of the cluster to match.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#name
   */
  readonly name?: string;

  /**
   * The service port for which this cluster was generated.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#portNumber
   */
  readonly portNumber?: number;

  /**
   * The fully qualified service name for this cluster.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#service
   */
  readonly service?: string;

  /**
   * The subset associated with the service.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchCluster' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchCluster(obj: EnvoyFilterSpecConfigPatchesMatchCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'portNumber': obj.portNumber,
    'service': obj.service,
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specific config generation context to match on.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchContext
 */
export enum EnvoyFilterSpecConfigPatchesMatchContext {
  /** ANY */
  ANY = "ANY",
  /** SIDECAR_INBOUND */
  SIDECAR_UNDERSCORE_INBOUND = "SIDECAR_INBOUND",
  /** SIDECAR_OUTBOUND */
  SIDECAR_UNDERSCORE_OUTBOUND = "SIDECAR_OUTBOUND",
  /** GATEWAY */
  GATEWAY = "GATEWAY",
}

/**
 * Match on envoy listener attributes.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchListener
 */
export interface EnvoyFilterSpecConfigPatchesMatchListener {
  /**
   * Match a specific filter chain in a listener.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#filterChain
   */
  readonly filterChain?: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain;

  /**
   * Match a specific listener filter.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#listenerFilter
   */
  readonly listenerFilter?: string;

  /**
   * Match a specific listener by its name.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#name
   */
  readonly name?: string;

  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#portName
   */
  readonly portName?: string;

  /**
   * The service port/gateway port to which traffic is being sent/received.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#portNumber
   */
  readonly portNumber?: number;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListener(obj: EnvoyFilterSpecConfigPatchesMatchListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterChain': toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChain(obj.filterChain),
    'listenerFilter': obj.listenerFilter,
    'name': obj.name,
    'portName': obj.portName,
    'portNumber': obj.portNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match on properties associated with a proxy.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchProxy
 */
export interface EnvoyFilterSpecConfigPatchesMatchProxy {
  /**
   * Match on the node metadata supplied by a proxy when connecting to Istio Pilot.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchProxy#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * A regular expression in golang regex format (RE2) that can be used to select proxies using a specific version of istio proxy.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchProxy#proxyVersion
   */
  readonly proxyVersion?: string;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchProxy(obj: EnvoyFilterSpecConfigPatchesMatchProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxyVersion': obj.proxyVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match on envoy HTTP route configuration attributes.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration
 */
export interface EnvoyFilterSpecConfigPatchesMatchRouteConfiguration {
  /**
   * The Istio gateway config's namespace/name for which this route configuration was generated.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#gateway
   */
  readonly gateway?: string;

  /**
   * Route configuration name to match on.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#name
   */
  readonly name?: string;

  /**
   * Applicable only for GATEWAY context.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#portName
   */
  readonly portName?: string;

  /**
   * The service port number or gateway server port number for which this route configuration was generated.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#portNumber
   */
  readonly portNumber?: number;

  /**
   * Match a specific virtual host in a route configuration and apply the patch to the virtual host.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#vhost
   */
  readonly vhost?: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchRouteConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfiguration(obj: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gateway': obj.gateway,
    'name': obj.name,
    'portName': obj.portName,
    'portNumber': obj.portNumber,
    'vhost': toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost(obj.vhost),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Determines the filter insertion order.
 *
 * @schema EnvoyFilterSpecConfigPatchesPatchFilterClass
 */
export enum EnvoyFilterSpecConfigPatchesPatchFilterClass {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** AUTHN */
  AUTHN = "AUTHN",
  /** AUTHZ */
  AUTHZ = "AUTHZ",
  /** STATS */
  STATS = "STATS",
}

/**
 * Determines how the patch should be applied.
 *
 * @schema EnvoyFilterSpecConfigPatchesPatchOperation
 */
export enum EnvoyFilterSpecConfigPatchesPatchOperation {
  /** INVALID */
  INVALID = "INVALID",
  /** MERGE */
  MERGE = "MERGE",
  /** ADD */
  ADD = "ADD",
  /** REMOVE */
  REMOVE = "REMOVE",
  /** INSERT_BEFORE */
  INSERT_UNDERSCORE_BEFORE = "INSERT_BEFORE",
  /** INSERT_AFTER */
  INSERT_UNDERSCORE_AFTER = "INSERT_AFTER",
  /** INSERT_FIRST */
  INSERT_UNDERSCORE_FIRST = "INSERT_FIRST",
  /** REPLACE */
  REPLACE = "REPLACE",
}

/**
 * Match a specific filter chain in a listener.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain
 */
export interface EnvoyFilterSpecConfigPatchesMatchListenerFilterChain {
  /**
   * Applies only to sidecars.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#applicationProtocols
   */
  readonly applicationProtocols?: string;

  /**
   * The destination_port value used by a filter chain's match condition.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#destinationPort
   */
  readonly destinationPort?: number;

  /**
   * The name of a specific filter to apply the patch to.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#filter
   */
  readonly filter?: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter;

  /**
   * The name assigned to the filter chain.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#name
   */
  readonly name?: string;

  /**
   * The SNI value used by a filter chain's match condition.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#sni
   */
  readonly sni?: string;

  /**
   * Applies only to `SIDECAR_INBOUND` context.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#transportProtocol
   */
  readonly transportProtocol?: string;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListenerFilterChain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChain(obj: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationProtocols': obj.applicationProtocols,
    'destinationPort': obj.destinationPort,
    'filter': toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter(obj.filter),
    'name': obj.name,
    'sni': obj.sni,
    'transportProtocol': obj.transportProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match a specific virtual host in a route configuration and apply the patch to the virtual host.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost
 */
export interface EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost {
  /**
   * The VirtualHosts objects generated by Istio are named as host:port, where the host typically corresponds to the VirtualService's host field or the hostname of a service in the registry.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost#name
   */
  readonly name?: string;

  /**
   * Match a specific route within the virtual host.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost#route
   */
  readonly route?: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost(obj: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'route': toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute(obj.route),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The name of a specific filter to apply the patch to.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter
 */
export interface EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter {
  /**
   * The filter name to match on.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter#name
   */
  readonly name?: string;

  /**
   * The next level filter within this filter to match upon.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter#subFilter
   */
  readonly subFilter?: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter(obj: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'subFilter': toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter(obj.subFilter),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match a specific route within the virtual host.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute
 */
export interface EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute {
  /**
   * Match a route with specific action type.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute#action
   */
  readonly action?: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction;

  /**
   * The Route objects generated by default are named as default.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute(obj: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The next level filter within this filter to match upon.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter
 */
export interface EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter {
  /**
   * The filter name to match on.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter(obj: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match a route with specific action type.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction
 */
export enum EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction {
  /** ANY */
  ANY = "ANY",
  /** ROUTE */
  ROUTE = "ROUTE",
  /** REDIRECT */
  REDIRECT = "REDIRECT",
  /** DIRECT_RESPONSE */
  DIRECT_UNDERSCORE_RESPONSE = "DIRECT_RESPONSE",
}

